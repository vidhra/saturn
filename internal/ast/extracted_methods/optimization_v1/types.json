{
  "\\Users\\AMD\\vidhra\\internal\\ast\\google-cloud-python\\packages\\google-cloud-optimization\\google\\cloud\\optimization_v1\\types\\async_model.py": [
    {
      "type": "request_class",
      "name": "InputConfig",
      "docstring": "The desired input location information.\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    gcs_source (google.cloud.optimization_v1.types.GcsSource):\n        The Google Cloud Storage location to read the\n        input from. This must be a single file.\n\n        This field is a member of `oneof`_ ``source``.\n    data_format (google.cloud.optimization_v1.types.DataFormat):\n        The input data format that used to store the\n        model in Cloud Storage.",
      "attributes": {
        "gcs_source": {
          "type": "google.cloud.optimization_v1.types.GcsSource",
          "description": "The Google Cloud Storage location to read the input from. This must be a single file.  This field is a member of `oneof`_ ``source``."
        },
        "data_format": {
          "type": "google.cloud.optimization_v1.types.DataFormat",
          "description": "The input data format that used to store the model in Cloud Storage."
        }
      }
    },
    {
      "type": "request_class",
      "name": "OutputConfig",
      "docstring": "The desired output location.\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    gcs_destination (google.cloud.optimization_v1.types.GcsDestination):\n        The Google Cloud Storage location to write\n        the output to.\n\n        This field is a member of `oneof`_ ``destination``.\n    data_format (google.cloud.optimization_v1.types.DataFormat):\n        The output data format that used to store the\n        results in Cloud Storage.",
      "attributes": {
        "gcs_destination": {
          "type": "google.cloud.optimization_v1.types.GcsDestination",
          "description": "The Google Cloud Storage location to write the output to.  This field is a member of `oneof`_ ``destination``."
        },
        "data_format": {
          "type": "google.cloud.optimization_v1.types.DataFormat",
          "description": "The output data format that used to store the results in Cloud Storage."
        }
      }
    },
    {
      "type": "request_class",
      "name": "GcsSource",
      "docstring": "The Google Cloud Storage location where the input file will\nbe read from.\n\nAttributes:\n    uri (str):\n        Required. URI of the Google Cloud Storage\n        location.",
      "attributes": {
        "uri": {
          "type": "str",
          "description": "Required. URI of the Google Cloud Storage location."
        }
      }
    },
    {
      "type": "request_class",
      "name": "GcsDestination",
      "docstring": "The Google Cloud Storage location where the output file will\nbe written to.\n\nAttributes:\n    uri (str):\n        Required. URI of the Google Cloud Storage\n        location.",
      "attributes": {
        "uri": {
          "type": "str",
          "description": "Required. URI of the Google Cloud Storage location."
        }
      }
    },
    {
      "type": "request_class",
      "name": "AsyncModelMetadata",
      "docstring": "The long running operation metadata for async model related\nmethods.\n\nAttributes:\n    state (google.cloud.optimization_v1.types.AsyncModelMetadata.State):\n        The state of the current operation.\n    state_message (str):\n        A message providing more details about the\n        current state of the operation. For example, the\n        error message if the operation is failed.\n    create_time (google.protobuf.timestamp_pb2.Timestamp):\n        The creation time of the operation.\n    update_time (google.protobuf.timestamp_pb2.Timestamp):\n        The last update time of the operation.",
      "attributes": {
        "state": {
          "type": "google.cloud.optimization_v1.types.AsyncModelMetadata.State",
          "description": "The state of the current operation."
        },
        "state_message": {
          "type": "str",
          "description": "A message providing more details about the current state of the operation. For example, the error message if the operation is failed."
        },
        "create_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "The creation time of the operation."
        },
        "update_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "The last update time of the operation."
        }
      }
    }
  ],
  "\\Users\\AMD\\vidhra\\internal\\ast\\google-cloud-python\\packages\\google-cloud-optimization\\google\\cloud\\optimization_v1\\types\\fleet_routing.py": [
    {
      "type": "request_class",
      "name": "OptimizeToursRequest",
      "docstring": "Request to be given to a tour optimization solver which\ndefines the shipment model to solve as well as optimization\nparameters.\n\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    parent (str):\n        Required. Target project and location to make a call.\n\n        Format: ``projects/{project-id}/locations/{location-id}``.\n\n        If no location is specified, a region will be chosen\n        automatically.\n    timeout (google.protobuf.duration_pb2.Duration):\n        If this timeout is set, the server returns a\n        response before the timeout period has elapsed\n        or the server deadline for synchronous requests\n        is reached, whichever is sooner.\n\n        For asynchronous requests, the server will\n        generate a solution (if possible) before the\n        timeout has elapsed.\n    model (google.cloud.optimization_v1.types.ShipmentModel):\n        Shipment model to solve.\n    solving_mode (google.cloud.optimization_v1.types.O",
      "attributes": {
        "parent": {
          "type": "str",
          "description": "Required. Target project and location to make a call.  Format: ``projects/{project-id}/locations/{location-id}``.  If no location is specified, a region will be chosen automatically."
        },
        "timeout": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "If this timeout is set, the server returns a response before the timeout period has elapsed or the server deadline for synchronous requests is reached, whichever is sooner.  For asynchronous requests, the server will generate a solution (if possible) before the timeout has elapsed."
        },
        "model": {
          "type": "google.cloud.optimization_v1.types.ShipmentModel",
          "description": "Shipment model to solve."
        },
        "solving_mode": {
          "type": "google.cloud.optimization_v1.types.OptimizeToursRequest.SolvingMode",
          "description": "By default, the solving mode is ``DEFAULT_SOLVE`` (0)."
        },
        "search_mode": {
          "type": "google.cloud.optimization_v1.types.OptimizeToursRequest.SearchMode",
          "description": "Search mode used to solve the request."
        },
        "injected_first_solution_routes": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentRoute]",
          "description": "Guide the optimization algorithm in finding a first solution that is similar to a previous solution.  The model is constrained when the first solution is built. Any shipments not performed on a route are implicitly skipped in the first solution, but they may be performed in successive solutions.  The solution must satisfy some basic validity assumptions:  -  for all routes, ``vehicle_index`` must be in range and not be duplicated. -  for all visits, ``shipment_index`` and ``visit_request_index`` must be in range. -  a shipment may only be referenced on one route. -  the pickup of a pickup-delivery shipment must be performed before the delivery. -  no more than one pickup alternative or delivery alternative of a shipment may be performed. -  for all routes, times are increasing (i.e., ``vehicle_start_time <= visits[0].start_time <= visits[1].start_time ... <= vehicle_end_time``). -  a shipment may only be performed on a vehicle that is allowed. A vehicle is allowed if [Shipment.allowed_vehicle_indices][google.cloud.optimization.v1.Shipment.allowed_vehicle_indices] is empty or its ``vehicle_index`` is included in [Shipment.allowed_vehicle_indices][google.cloud.optimization.v1.Shipment.allowed_vehicle_indices].  If the injected solution is not feasible, a validation error is not necessarily returned and an error indicating infeasibility may be returned instead."
        },
        "injected_solution_constraint": {
          "type": "google.cloud.optimization_v1.types.InjectedSolutionConstraint",
          "description": "Constrain the optimization algorithm to find a final solution that is similar to a previous solution. For example, this may be used to freeze portions of routes which have already been completed or which are to be completed but must not be modified.  If the injected solution is not feasible, a validation error is not necessarily returned and an error indicating infeasibility may be returned instead."
        },
        "refresh_details_routes": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentRoute]",
          "description": "If non-empty, the given routes will be refreshed, without modifying their underlying sequence of visits or travel times: only other details will be updated. This does not solve the model.  As of 2020/11, this only populates the polylines of non-empty routes and requires that ``populate_polylines`` is true.  The ``route_polyline`` fields of the passed-in routes may be inconsistent with route ``transitions``.  This field must not be used together with ``injected_first_solution_routes`` or ``injected_solution_constraint``.  ``Shipment.ignore`` and ``Vehicle.ignore`` have no effect on the behavior. Polylines are still populated between all visits in all non-empty routes regardless of whether the related shipments or vehicles are ignored."
        },
        "interpret_injected_solutions_using_labels": {
          "type": "bool",
          "description": "If true:  -  uses [ShipmentRoute.vehicle_label][google.cloud.optimization.v1.ShipmentRoute.vehicle_label] instead of ``vehicle_index`` to match routes in an injected solution with vehicles in the request; reuses the mapping of original [ShipmentRoute.vehicle_index][google.cloud.optimization.v1.ShipmentRoute.vehicle_index] to new [ShipmentRoute.vehicle_index][google.cloud.optimization.v1.ShipmentRoute.vehicle_index] to update [ConstraintRelaxation.vehicle_indices][google.cloud.optimization.v1.InjectedSolutionConstraint.ConstraintRelaxation.vehicle_indices] if non-empty, but the mapping must be unambiguous (i.e., multiple ``ShipmentRoute``\\ s must not share the same original ``vehicle_index``). -  uses [ShipmentRoute.Visit.shipment_label][google.cloud.optimization.v1.ShipmentRoute.Visit.shipment_label] instead of ``shipment_index`` to match visits in an injected solution with shipments in the request; -  uses [SkippedShipment.label][google.cloud.optimization.v1.SkippedShipment.label] instead of [SkippedShipment.index][google.cloud.optimization.v1.SkippedShipment.index] to match skipped shipments in the injected solution with request shipments.  This interpretation applies to the ``injected_first_solution_routes``, ``injected_solution_constraint``, and ``refresh_details_routes`` fields. It can be used when shipment or vehicle indices in the request have changed since the solution was created, perhaps because shipments or vehicles have been removed from or added to the request.  If true, labels in the following categories must appear at most once in their category:  -  [Vehicle.label][google.cloud.optimization.v1.Vehicle.label] in the request; -  [Shipment.label][google.cloud.optimization.v1.Shipment.label] in the request; -  [ShipmentRoute.vehicle_label][google.cloud.optimization.v1.ShipmentRoute.vehicle_label] in the injected solution; -  [SkippedShipment.label][google.cloud.optimization.v1.SkippedShipment.label] and [ShipmentRoute.Visit.shipment_label][google.cloud.optimization.v1.ShipmentRoute.Visit.shipment_label] in the injected solution (except pickup/delivery visit pairs, whose ``shipment_label`` must appear twice).  If a ``vehicle_label`` in the injected solution does not correspond to a request vehicle, the corresponding route is removed from the solution along with its visits. If a ``shipment_label`` in the injected solution does not correspond to a request shipment, the corresponding visit is removed from the solution. If a [SkippedShipment.label][google.cloud.optimization.v1.SkippedShipment.label] in the injected solution does not correspond to a request shipment, the ``SkippedShipment`` is removed from the solution.  Removing route visits or entire routes from an injected solution may have an effect on the implied constraints, which may lead to change in solution, validation errors, or infeasibility.  NOTE: The caller must ensure that each [Vehicle.label][google.cloud.optimization.v1.Vehicle.label] (resp. [Shipment.label][google.cloud.optimization.v1.Shipment.label]) uniquely identifies a vehicle (resp. shipment) entity used across the two relevant requests: the past request that produced the ``OptimizeToursResponse`` used in the injected solution and the current request that includes the injected solution. The uniqueness checks described above are not enough to guarantee this requirement."
        },
        "consider_road_traffic": {
          "type": "bool",
          "description": "Consider traffic estimation in calculating ``ShipmentRoute`` fields [Transition.travel_duration][google.cloud.optimization.v1.ShipmentRoute.Transition.travel_duration], [Visit.start_time][google.cloud.optimization.v1.ShipmentRoute.Visit.start_time], and ``vehicle_end_time``; in setting the [ShipmentRoute.has_traffic_infeasibilities][google.cloud.optimization.v1.ShipmentRoute.has_traffic_infeasibilities] field, and in calculating the [OptimizeToursResponse.total_cost][google.cloud.optimization.v1.OptimizeToursResponse.total_cost] field."
        },
        "populate_polylines": {
          "type": "bool",
          "description": "If true, polylines will be populated in response ``ShipmentRoute``\\ s."
        },
        "populate_transition_polylines": {
          "type": "bool",
          "description": "If true, polylines will be populated in response [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions]. Note that in this case, the polylines will also be populated in the deprecated ``travel_steps``."
        },
        "allow_large_deadline_despite_interruption_risk": {
          "type": "bool",
          "description": "If this is set, then the request can have a deadline (see https://grpc.io/blog/deadlines) of up to 60 minutes. Otherwise, the maximum deadline is only 30 minutes. Note that long-lived requests have a significantly larger (but still small) risk of interruption."
        },
        "use_geodesic_distances": {
          "type": "bool",
          "description": "If true, travel distances will be computed using geodesic distances instead of Google Maps distances, and travel times will be computed using geodesic distances with a speed defined by ``geodesic_meters_per_second``."
        },
        "geodesic_meters_per_second": {
          "type": "float",
          "description": "When ``use_geodesic_distances`` is true, this field must be set and defines the speed applied to compute travel times. Its value must be at least 1.0 meters/seconds.  This field is a member of `oneof`_ ``_geodesic_meters_per_second``."
        },
        "max_validation_errors": {
          "type": "int",
          "description": "Truncates the number of validation errors returned. These errors are typically attached to an INVALID_ARGUMENT error payload as a BadRequest error detail (https://cloud.google.com/apis/design/errors#error_details), unless solving_mode=VALIDATE_ONLY: see the [OptimizeToursResponse.validation_errors][google.cloud.optimization.v1.OptimizeToursResponse.validation_errors] field. This defaults to 100 and is capped at 10,000.  This field is a member of `oneof`_ ``_max_validation_errors``."
        },
        "label": {
          "type": "str",
          "description": "Label that may be used to identify this request, reported back in the [OptimizeToursResponse.request_label][google.cloud.optimization.v1.OptimizeToursResponse.request_label]."
        },
        "populate_travel_step_polylines": {
          "type": "bool",
          "description": "Deprecated: Use [OptimizeToursRequest.populate_transition_polylines][google.cloud.optimization.v1.OptimizeToursRequest.populate_transition_polylines] instead. If true, polylines will be populated in response [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions]. Note that in this case, the polylines will also be populated in the deprecated ``travel_steps``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "OptimizeToursResponse",
      "docstring": "Response after solving a tour optimization problem containing\nthe routes followed by each vehicle, the shipments which have\nbeen skipped and the overall cost of the solution.\n\nAttributes:\n    routes (MutableSequence[google.cloud.optimization_v1.types.ShipmentRoute]):\n        Routes computed for each vehicle; the i-th\n        route corresponds to the i-th vehicle in the\n        model.\n    request_label (str):\n        Copy of the\n        [OptimizeToursRequest.label][google.cloud.optimization.v1.OptimizeToursRequest.label],\n        if a label was specified in the request.\n    skipped_shipments (MutableSequence[google.cloud.optimization_v1.types.SkippedShipment]):\n        The list of all shipments skipped.\n    validation_errors (MutableSequence[google.cloud.optimization_v1.types.OptimizeToursValidationError]):\n        List of all the validation errors that we were able to\n        detect independently. See the \"MULTIPLE ERRORS\" explanation\n        for the\n        [OptimizeToursValidationError][google.cloud.optimiz",
      "attributes": {
        "routes": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentRoute]",
          "description": "Routes computed for each vehicle; the i-th route corresponds to the i-th vehicle in the model."
        },
        "request_label": {
          "type": "str",
          "description": "Copy of the [OptimizeToursRequest.label][google.cloud.optimization.v1.OptimizeToursRequest.label], if a label was specified in the request."
        },
        "skipped_shipments": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.SkippedShipment]",
          "description": "The list of all shipments skipped."
        },
        "validation_errors": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.OptimizeToursValidationError]",
          "description": "List of all the validation errors that we were able to detect independently. See the \"MULTIPLE ERRORS\" explanation for the [OptimizeToursValidationError][google.cloud.optimization.v1.OptimizeToursValidationError] message."
        },
        "metrics": {
          "type": "google.cloud.optimization_v1.types.OptimizeToursResponse.Metrics",
          "description": "Duration, distance and usage metrics for this solution."
        },
        "total_cost": {
          "type": "float",
          "description": "Deprecated: Use [Metrics.total_cost][google.cloud.optimization.v1.OptimizeToursResponse.Metrics.total_cost] instead. Total cost of the solution. This takes into account all costs: costs per per hour and travel hour, fixed vehicle costs, unperformed shipment penalty costs, global duration cost, etc."
        }
      }
    },
    {
      "type": "request_class",
      "name": "BatchOptimizeToursRequest",
      "docstring": "Request to batch optimize tours as an asynchronous operation. Each\ninput file should contain one ``OptimizeToursRequest``, and each\noutput file will contain one ``OptimizeToursResponse``. The request\ncontains information to read/write and parse the files. All the\ninput and output files should be under the same project.\n\nAttributes:\n    parent (str):\n        Required. Target project and location to make a call.\n\n        Format: ``projects/{project-id}/locations/{location-id}``.\n\n        If no location is specified, a region will be chosen\n        automatically.\n    model_configs (MutableSequence[google.cloud.optimization_v1.types.BatchOptimizeToursRequest.AsyncModelConfig]):\n        Required. Input/Output information each\n        purchase model, such as file paths and data\n        formats.",
      "attributes": {
        "parent": {
          "type": "str",
          "description": "Required. Target project and location to make a call.  Format: ``projects/{project-id}/locations/{location-id}``.  If no location is specified, a region will be chosen automatically."
        },
        "model_configs": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.BatchOptimizeToursRequest.AsyncModelConfig]",
          "description": "Required. Input/Output information each purchase model, such as file paths and data formats."
        }
      }
    },
    {
      "type": "request_class",
      "name": "BatchOptimizeToursResponse",
      "docstring": "Response to a ``BatchOptimizeToursRequest``. This is returned in the\nLRO Operation after the operation is complete.",
      "attributes": {}
    },
    {
      "type": "request_class",
      "name": "ShipmentModel",
      "docstring": "A shipment model contains a set of shipments which must be performed\nby a set of vehicles, while minimizing the overall cost, which is\nthe sum of:\n\n-  the cost of routing the vehicles (sum of cost per total time,\n   cost per travel time, and fixed cost over all vehicles).\n-  the unperformed shipment penalties.\n-  the cost of the global duration of the shipments\n\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    shipments (MutableSequence[google.cloud.optimization_v1.types.Shipment]):\n        Set of shipments which must be performed in\n        the model.\n    vehicles (MutableSequence[google.cloud.optimization_v1.types.Vehicle]):\n        Set of vehicles which can be used to perform\n        visits.\n    max_active_vehicles (int):\n        Constrains the maximum number of active\n        vehicles. A vehicle is active if its route\n        performs at least one shipment. This can be used\n        to limit the number of routes in the case where\n ",
      "attributes": {
        "shipments": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.Shipment]",
          "description": "Set of shipments which must be performed in the model."
        },
        "vehicles": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.Vehicle]",
          "description": "Set of vehicles which can be used to perform visits."
        },
        "max_active_vehicles": {
          "type": "int",
          "description": "Constrains the maximum number of active vehicles. A vehicle is active if its route performs at least one shipment. This can be used to limit the number of routes in the case where there are fewer drivers than vehicles and that the fleet of vehicles is heterogeneous. The optimization will then select the best subset of vehicles to use. Must be strictly positive.  This field is a member of `oneof`_ ``_max_active_vehicles``."
        },
        "global_start_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Global start and end time of the model: no times outside of this range can be considered valid.  The model's time span must be less than a year, i.e. the ``global_end_time`` and the ``global_start_time`` must be within 31536000 seconds of each other.  When using ``cost_per_*hour`` fields, you might want to set this window to a smaller interval to increase performance (eg. if you model a single day, you should set the global time limits to that day). If unset, 00:00:00 UTC, January 1, 1970 (i.e. seconds: 0, nanos: 0) is used as default."
        },
        "global_end_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "If unset, 00:00:00 UTC, January 1, 1971 (i.e. seconds: 31536000, nanos: 0) is used as default."
        },
        "global_duration_cost_per_hour": {
          "type": "float",
          "description": "The \"global duration\" of the overall plan is the difference between the earliest effective start time and the latest effective end time of all vehicles. Users can assign a cost per hour to that quantity to try and optimize for earliest job completion, for example. This cost must be in the same unit as [Shipment.penalty_cost][google.cloud.optimization.v1.Shipment.penalty_cost]."
        },
        "duration_distance_matrices": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentModel.DurationDistanceMatrix]",
          "description": "Specifies duration and distance matrices used in the model. If this field is empty, Google Maps or geodesic distances will be used instead, depending on the value of the ``use_geodesic_distances`` field. If it is not empty, ``use_geodesic_distances`` cannot be true and neither ``duration_distance_matrix_src_tags`` nor ``duration_distance_matrix_dst_tags`` can be empty.  Usage examples:  -  There are two locations: locA and locB. -  1 vehicle starting its route at locA and ending it at locA. -  1 pickup visit request at locB.  ::  model { vehicles { start_tags: \"locA\"  end_tags: \"locA\" } shipments { pickups { tags: \"locB\" } } duration_distance_matrix_src_tags: \"locA\" duration_distance_matrix_src_tags: \"locB\" duration_distance_matrix_dst_tags: \"locA\" duration_distance_matrix_dst_tags: \"locB\" duration_distance_matrices { rows {  # from: locA durations { seconds: 0 }   meters: 0    # to: locA durations { seconds: 100 } meters: 1000 # to: locB } rows {  # from: locB durations { seconds: 102 } meters: 990 # to: locA durations { seconds: 0 }   meters: 0   # to: locB } } }  -  There are three locations: locA, locB and locC. -  1 vehicle starting its route at locA and ending it at locB, using matrix \"fast\". -  1 vehicle starting its route at locB and ending it at locB, using matrix \"slow\". -  1 vehicle starting its route at locB and ending it at locB, using matrix \"fast\". -  1 pickup visit request at locC.  ::  model { vehicles { start_tags: \"locA\" end_tags: \"locB\" start_tags: \"fast\" } vehicles { start_tags: \"locB\" end_tags: \"locB\" start_tags: \"slow\" } vehicles { start_tags: \"locB\" end_tags: \"locB\" start_tags: \"fast\" } shipments { pickups { tags: \"locC\" } } duration_distance_matrix_src_tags: \"locA\" duration_distance_matrix_src_tags: \"locB\" duration_distance_matrix_src_tags: \"locC\" duration_distance_matrix_dst_tags: \"locB\" duration_distance_matrix_dst_tags: \"locC\" duration_distance_matrices { vehicle_start_tag: \"fast\" rows {  # from: locA durations { seconds: 1000 } meters: 2000 # to: locB durations { seconds: 600 }  meters: 1000 # to: locC } rows {  # from: locB durations { seconds: 0 }   meters: 0    # to: locB durations { seconds: 700 } meters: 1200 # to: locC } rows {  # from: locC durations { seconds: 702 } meters: 1190 # to: locB durations { seconds: 0 }   meters: 0    # to: locC } } duration_distance_matrices { vehicle_start_tag: \"slow\" rows {  # from: locA durations { seconds: 1800 } meters: 2001 # to: locB durations { seconds: 900 }  meters: 1002 # to: locC } rows {  # from: locB durations { seconds: 0 }    meters: 0    # to: locB durations { seconds: 1000 } meters: 1202 # to: locC } rows {  # from: locC durations { seconds: 1001 } meters: 1195 # to: locB durations { seconds: 0 }    meters: 0    # to: locC } } }"
        },
        "duration_distance_matrix_src_tags": {
          "type": "MutableSequence[str]",
          "description": "Tags defining the sources of the duration and distance matrices; ``duration_distance_matrices(i).rows(j)`` defines durations and distances from visits with tag ``duration_distance_matrix_src_tags(j)`` to other visits in matrix i.  Tags correspond to [VisitRequest.tags][google.cloud.optimization.v1.Shipment.VisitRequest.tags] or [Vehicle.start_tags][google.cloud.optimization.v1.Vehicle.start_tags]. A given ``VisitRequest`` or ``Vehicle`` must match exactly one tag in this field. Note that a ``Vehicle``'s source, destination and matrix tags may be the same; similarly a ``VisitRequest``'s source and destination tags may be the same. All tags must be different and cannot be empty strings. If this field is not empty, then ``duration_distance_matrices`` must not be empty."
        },
        "duration_distance_matrix_dst_tags": {
          "type": "MutableSequence[str]",
          "description": "Tags defining the destinations of the duration and distance matrices; ``duration_distance_matrices(i).rows(j).durations(k)`` (resp. ``duration_distance_matrices(i).rows(j).meters(k))`` defines the duration (resp. the distance) of the travel from visits with tag ``duration_distance_matrix_src_tags(j)`` to visits with tag ``duration_distance_matrix_dst_tags(k)`` in matrix i.  Tags correspond to [VisitRequest.tags][google.cloud.optimization.v1.Shipment.VisitRequest.tags] or [Vehicle.start_tags][google.cloud.optimization.v1.Vehicle.start_tags]. A given ``VisitRequest`` or ``Vehicle`` must match exactly one tag in this field. Note that a ``Vehicle``'s source, destination and matrix tags may be the same; similarly a ``VisitRequest``'s source and destination tags may be the same. All tags must be different and cannot be empty strings. If this field is not empty, then ``duration_distance_matrices`` must not be empty."
        },
        "transition_attributes": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.TransitionAttributes]",
          "description": "Transition attributes added to the model."
        },
        "shipment_type_incompatibilities": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentTypeIncompatibility]",
          "description": "Sets of incompatible shipment_types (see ``ShipmentTypeIncompatibility``)."
        },
        "shipment_type_requirements": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentTypeRequirement]",
          "description": "Sets of ``shipment_type`` requirements (see ``ShipmentTypeRequirement``)."
        },
        "precedence_rules": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentModel.PrecedenceRule]",
          "description": "Set of precedence rules which must be enforced in the model."
        },
        "break_rules": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentModel.BreakRule]",
          "description": "Deprecated: No longer used. Set of break rules used in the model. Each vehicle specifies the ``BreakRule`` that applies to it via the [Vehicle.break_rule_indices][google.cloud.optimization.v1.Vehicle.break_rule_indices] field (which must be a singleton)."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Shipment",
      "docstring": "The shipment of a single item, from one of its pickups to one\nof its deliveries. For the shipment to be considered as\nperformed, a unique vehicle must visit one of its pickup\nlocations (and decrease its spare capacities accordingly), then\nvisit one of its delivery locations later on (and therefore\nre-increase its spare capacities accordingly).\n\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    pickups (MutableSequence[google.cloud.optimization_v1.types.Shipment.VisitRequest]):\n        Set of pickup alternatives associated to the\n        shipment. If not specified, the vehicle only\n        needs to visit a location corresponding to the\n        deliveries.\n    deliveries (MutableSequence[google.cloud.optimization_v1.types.Shipment.VisitRequest]):\n        Set of delivery alternatives associated to\n        the shipment. If not specified, the vehicle only\n        needs to visit a location corresponding to the\n        pickups.\n    load_deman",
      "attributes": {
        "pickups": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.Shipment.VisitRequest]",
          "description": "Set of pickup alternatives associated to the shipment. If not specified, the vehicle only needs to visit a location corresponding to the deliveries."
        },
        "deliveries": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.Shipment.VisitRequest]",
          "description": "Set of delivery alternatives associated to the shipment. If not specified, the vehicle only needs to visit a location corresponding to the pickups."
        },
        "load_demands": {
          "type": "MutableMapping[str, google.cloud.optimization_v1.types.Shipment.Load]",
          "description": "Load demands of the shipment (for example weight, volume, number of pallets etc). The keys in the map should be identifiers describing the type of the corresponding load, ideally also including the units. For example: \"weight_kg\", \"volume_gallons\", \"pallet_count\", etc. If a given key does not appear in the map, the corresponding load is considered as null."
        },
        "penalty_cost": {
          "type": "float",
          "description": "If the shipment is not completed, this penalty is added to the overall cost of the routes. A shipment is considered completed if one of its pickup and delivery alternatives is visited. The cost may be expressed in the same unit used for all other cost-related fields in the model and must be positive.  *IMPORTANT*: If this penalty is not specified, it is considered infinite, i.e. the shipment must be completed.  This field is a member of `oneof`_ ``_penalty_cost``."
        },
        "allowed_vehicle_indices": {
          "type": "MutableSequence[int]",
          "description": "The set of vehicles that may perform this shipment. If empty, all vehicles may perform it. Vehicles are given by their index in the ``ShipmentModel``'s ``vehicles`` list."
        },
        "costs_per_vehicle": {
          "type": "MutableSequence[float]",
          "description": "Specifies the cost that is incurred when this shipment is delivered by each vehicle. If specified, it must have EITHER:  -  the same number of elements as ``costs_per_vehicle_indices``. ``costs_per_vehicle[i]`` corresponds to vehicle ``costs_per_vehicle_indices[i]`` of the model. -  the same number of elements as there are vehicles in the model. The i-th element corresponds to vehicle #i of the model.  These costs must be in the same unit as ``penalty_cost`` and must not be negative. Leave this field empty, if there are no such costs."
        },
        "costs_per_vehicle_indices": {
          "type": "MutableSequence[int]",
          "description": "Indices of the vehicles to which ``costs_per_vehicle`` applies. If non-empty, it must have the same number of elements as ``costs_per_vehicle``. A vehicle index may not be specified more than once. If a vehicle is excluded from ``costs_per_vehicle_indices``, its cost is zero."
        },
        "pickup_to_delivery_relative_detour_limit": {
          "type": "float",
          "description": "Specifies the maximum relative detour time compared to the shortest path from pickup to delivery. If specified, it must be nonnegative, and the shipment must contain at least a pickup and a delivery.  For example, let t be the shortest time taken to go from the selected pickup alternative directly to the selected delivery alternative. Then setting ``pickup_to_delivery_relative_detour_limit`` enforces:  ::  start_time(delivery) - start_time(pickup) <= std::ceil(t * (1.0 + pickup_to_delivery_relative_detour_limit))  If both relative and absolute limits are specified on the same shipment, the more constraining limit is used for each possible pickup/delivery pair. As of 2017/10, detours are only supported when travel durations do not depend on vehicles.  This field is a member of `oneof`_ ``_pickup_to_delivery_relative_detour_limit``."
        },
        "pickup_to_delivery_absolute_detour_limit": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Specifies the maximum absolute detour time compared to the shortest path from pickup to delivery. If specified, it must be nonnegative, and the shipment must contain at least a pickup and a delivery.  For example, let t be the shortest time taken to go from the selected pickup alternative directly to the selected delivery alternative. Then setting ``pickup_to_delivery_absolute_detour_limit`` enforces:  ::  start_time(delivery) - start_time(pickup) <= t + pickup_to_delivery_absolute_detour_limit  If both relative and absolute limits are specified on the same shipment, the more constraining limit is used for each possible pickup/delivery pair. As of 2017/10, detours are only supported when travel durations do not depend on vehicles."
        },
        "pickup_to_delivery_time_limit": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Specifies the maximum duration from start of pickup to start of delivery of a shipment. If specified, it must be nonnegative, and the shipment must contain at least a pickup and a delivery. This does not depend on which alternatives are selected for pickup and delivery, nor on vehicle speed. This can be specified alongside maximum detour constraints: the solution will respect both specifications."
        },
        "shipment_type": {
          "type": "str",
          "description": "Non-empty string specifying a \"type\" for this shipment. This feature can be used to define incompatibilities or requirements between ``shipment_types`` (see ``shipment_type_incompatibilities`` and ``shipment_type_requirements`` in ``ShipmentModel``).  Differs from ``visit_types`` which is specified for a single visit: All pickup/deliveries belonging to the same shipment share the same ``shipment_type``."
        },
        "label": {
          "type": "str",
          "description": "Specifies a label for this shipment. This label is reported in the response in the ``shipment_label`` of the corresponding [ShipmentRoute.Visit][google.cloud.optimization.v1.ShipmentRoute.Visit]."
        },
        "ignore": {
          "type": "bool",
          "description": "If true, skip this shipment, but don't apply a ``penalty_cost``.  Ignoring a shipment results in a validation error when there are any ``shipment_type_requirements`` in the model.  Ignoring a shipment that is performed in ``injected_first_solution_routes`` or ``injected_solution_constraint`` is permitted; the solver removes the related pickup/delivery visits from the performing route. ``precedence_rules`` that reference ignored shipments will also be ignored."
        },
        "demands": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.CapacityQuantity]",
          "description": "Deprecated: Use [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands] instead."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ShipmentTypeIncompatibility",
      "docstring": "Specifies incompatibilties between shipments depending on their\nshipment_type. The appearance of incompatible shipments on the same\nroute is restricted based on the incompatibility mode.\n\nAttributes:\n    types (MutableSequence[str]):\n        List of incompatible types. Two shipments having different\n        ``shipment_types`` among those listed are \"incompatible\".\n    incompatibility_mode (google.cloud.optimization_v1.types.ShipmentTypeIncompatibility.IncompatibilityMode):\n        Mode applied to the incompatibility.",
      "attributes": {
        "types": {
          "type": "MutableSequence[str]",
          "description": "List of incompatible types. Two shipments having different ``shipment_types`` among those listed are \"incompatible\"."
        },
        "incompatibility_mode": {
          "type": "google.cloud.optimization_v1.types.ShipmentTypeIncompatibility.IncompatibilityMode",
          "description": "Mode applied to the incompatibility."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ShipmentTypeRequirement",
      "docstring": "Specifies requirements between shipments based on their\nshipment_type. The specifics of the requirement are defined by the\nrequirement mode.\n\nAttributes:\n    required_shipment_type_alternatives (MutableSequence[str]):\n        List of alternative shipment types required by the\n        ``dependent_shipment_types``.\n    dependent_shipment_types (MutableSequence[str]):\n        All shipments with a type in the\n        ``dependent_shipment_types`` field require at least one\n        shipment of type ``required_shipment_type_alternatives`` to\n        be visited on the same route.\n\n        NOTE: Chains of requirements such that a ``shipment_type``\n        depends on itself are not allowed.\n    requirement_mode (google.cloud.optimization_v1.types.ShipmentTypeRequirement.RequirementMode):\n        Mode applied to the requirement.",
      "attributes": {
        "required_shipment_type_alternatives": {
          "type": "MutableSequence[str]",
          "description": "List of alternative shipment types required by the ``dependent_shipment_types``."
        },
        "dependent_shipment_types": {
          "type": "MutableSequence[str]",
          "description": "All shipments with a type in the ``dependent_shipment_types`` field require at least one shipment of type ``required_shipment_type_alternatives`` to be visited on the same route.  NOTE: Chains of requirements such that a ``shipment_type`` depends on itself are not allowed."
        },
        "requirement_mode": {
          "type": "google.cloud.optimization_v1.types.ShipmentTypeRequirement.RequirementMode",
          "description": "Mode applied to the requirement."
        }
      }
    },
    {
      "type": "request_class",
      "name": "RouteModifiers",
      "docstring": "Encapsulates a set of optional conditions to satisfy when\ncalculating vehicle routes. This is similar to ``RouteModifiers`` in\nthe Google Maps Platform API; see:\nhttps://developers.google.com/maps/documentation/routes/reference/rest/v2/RouteModifiers.\n\nAttributes:\n    avoid_tolls (bool):\n        Specifies whether to avoid toll roads where\n        reasonable. Preference will be given to routes\n        not containing toll roads. Applies only to\n        motorized travel modes.\n    avoid_highways (bool):\n        Specifies whether to avoid highways where\n        reasonable. Preference will be given to routes\n        not containing highways. Applies only to\n        motorized travel modes.\n    avoid_ferries (bool):\n        Specifies whether to avoid ferries where\n        reasonable. Preference will be given to routes\n        not containing travel by ferries. Applies only\n        to motorized travel modes.\n    avoid_indoor (bool):\n        Optional. Specifies whether to avoid navigating indoors\n        where reasonabl",
      "attributes": {
        "avoid_tolls": {
          "type": "bool",
          "description": "Specifies whether to avoid toll roads where reasonable. Preference will be given to routes not containing toll roads. Applies only to motorized travel modes."
        },
        "avoid_highways": {
          "type": "bool",
          "description": "Specifies whether to avoid highways where reasonable. Preference will be given to routes not containing highways. Applies only to motorized travel modes."
        },
        "avoid_ferries": {
          "type": "bool",
          "description": "Specifies whether to avoid ferries where reasonable. Preference will be given to routes not containing travel by ferries. Applies only to motorized travel modes."
        },
        "avoid_indoor": {
          "type": "bool",
          "description": "Optional. Specifies whether to avoid navigating indoors where reasonable. Preference will be given to routes not containing indoor navigation. Applies only to the ``WALKING`` travel mode."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Vehicle",
      "docstring": "Models a vehicle in a shipment problem. Solving a shipment problem\nwill build a route starting from ``start_location`` and ending at\n``end_location`` for this vehicle. A route is a sequence of visits\n(see ``ShipmentRoute``).\n\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    travel_mode (google.cloud.optimization_v1.types.Vehicle.TravelMode):\n        The travel mode which affects the roads usable by the\n        vehicle and its speed. See also\n        ``travel_duration_multiple``.\n    route_modifiers (google.cloud.optimization_v1.types.RouteModifiers):\n        Optional. A set of conditions to satisfy that\n        affect the way routes are calculated for the\n        given vehicle.\n    start_location (google.type.latlng_pb2.LatLng):\n        Geographic location where the vehicle starts before picking\n        up any shipments. If not specified, the vehicle starts at\n        its first pickup. If the shipment model has duration and\n        di",
      "attributes": {
        "travel_mode": {
          "type": "google.cloud.optimization_v1.types.Vehicle.TravelMode",
          "description": "The travel mode which affects the roads usable by the vehicle and its speed. See also ``travel_duration_multiple``."
        },
        "route_modifiers": {
          "type": "google.cloud.optimization_v1.types.RouteModifiers",
          "description": "Optional. A set of conditions to satisfy that affect the way routes are calculated for the given vehicle."
        },
        "start_location": {
          "type": "google.type.latlng_pb2.LatLng",
          "description": "Geographic location where the vehicle starts before picking up any shipments. If not specified, the vehicle starts at its first pickup. If the shipment model has duration and distance matrices, ``start_location`` must not be specified."
        },
        "start_waypoint": {
          "type": "google.cloud.optimization_v1.types.Waypoint",
          "description": "Waypoint representing a geographic location where the vehicle starts before picking up any shipments. If neither ``start_waypoint`` nor ``start_location`` is specified, the vehicle starts at its first pickup. If the shipment model has duration and distance matrices, ``start_waypoint`` must not be specified."
        },
        "end_location": {
          "type": "google.type.latlng_pb2.LatLng",
          "description": "Geographic location where the vehicle ends after it has completed its last ``VisitRequest``. If not specified the vehicle's ``ShipmentRoute`` ends immediately when it completes its last ``VisitRequest``. If the shipment model has duration and distance matrices, ``end_location`` must not be specified."
        },
        "end_waypoint": {
          "type": "google.cloud.optimization_v1.types.Waypoint",
          "description": "Waypoint representing a geographic location where the vehicle ends after it has completed its last ``VisitRequest``. If neither ``end_waypoint`` nor ``end_location`` is specified, the vehicle's ``ShipmentRoute`` ends immediately when it completes its last ``VisitRequest``. If the shipment model has duration and distance matrices, ``end_waypoint`` must not be specified."
        },
        "start_tags": {
          "type": "MutableSequence[str]",
          "description": "Specifies tags attached to the start of the vehicle's route. Empty or duplicate strings are not allowed."
        },
        "end_tags": {
          "type": "MutableSequence[str]",
          "description": "Specifies tags attached to the end of the vehicle's route. Empty or duplicate strings are not allowed."
        },
        "start_time_windows": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.TimeWindow]",
          "description": "Time windows during which the vehicle may depart its start location. They must be within the global time limits (see [ShipmentModel.global_*][google.cloud.optimization.v1.ShipmentModel.global_start_time] fields). If unspecified, there is no limitation besides those global time limits.  Time windows belonging to the same repeated field must be disjoint, i.e. no time window can overlap with or be adjacent to another, and they must be in chronological order.  ``cost_per_hour_after_soft_end_time`` and ``soft_end_time`` can only be set if there is a single time window."
        },
        "end_time_windows": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.TimeWindow]",
          "description": "Time windows during which the vehicle may arrive at its end location. They must be within the global time limits (see [ShipmentModel.global_*][google.cloud.optimization.v1.ShipmentModel.global_start_time] fields). If unspecified, there is no limitation besides those global time limits.  Time windows belonging to the same repeated field must be disjoint, i.e. no time window can overlap with or be adjacent to another, and they must be in chronological order.  ``cost_per_hour_after_soft_end_time`` and ``soft_end_time`` can only be set if there is a single time window."
        },
        "travel_duration_multiple": {
          "type": "float",
          "description": "Specifies a multiplicative factor that can be used to increase or decrease travel times of this vehicle. For example, setting this to 2.0 means that this vehicle is slower and has travel times that are twice what they are for standard vehicles. This multiple does not affect visit durations. It does affect cost if ``cost_per_hour`` or ``cost_per_traveled_hour`` are specified. This must be in the range [0.001, 1000.0]. If unset, the vehicle is standard, and this multiple is considered 1.0.  WARNING: Travel times will be rounded to the nearest second after this multiple is applied but before performing any numerical operations, thus, a small multiple may result in a loss of precision.  See also ``extra_visit_duration_for_visit_type`` below.  This field is a member of `oneof`_ ``_travel_duration_multiple``."
        },
        "unloading_policy": {
          "type": "google.cloud.optimization_v1.types.Vehicle.UnloadingPolicy",
          "description": "Unloading policy enforced on the vehicle."
        },
        "load_limits": {
          "type": "MutableMapping[str, google.cloud.optimization_v1.types.Vehicle.LoadLimit]",
          "description": "Capacities of the vehicle (weight, volume, # of pallets for example). The keys in the map are the identifiers of the type of load, consistent with the keys of the [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands] field. If a given key is absent from this map, the corresponding capacity is considered to be limitless."
        },
        "cost_per_hour": {
          "type": "float",
          "description": "Vehicle costs: all costs add up and must be in the same unit as [Shipment.penalty_cost][google.cloud.optimization.v1.Shipment.penalty_cost].  Cost per hour of the vehicle route. This cost is applied to the total time taken by the route, and includes travel time, waiting time, and visit time. Using ``cost_per_hour`` instead of just ``cost_per_traveled_hour`` may result in additional latency."
        },
        "cost_per_traveled_hour": {
          "type": "float",
          "description": "Cost per traveled hour of the vehicle route. This cost is applied only to travel time taken by the route (i.e., that reported in [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions]), and excludes waiting time and visit time."
        },
        "cost_per_kilometer": {
          "type": "float",
          "description": "Cost per kilometer of the vehicle route. This cost is applied to the distance reported in the [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions] and does not apply to any distance implicitly traveled from the ``arrival_location`` to the ``departure_location`` of a single ``VisitRequest``."
        },
        "fixed_cost": {
          "type": "float",
          "description": "Fixed cost applied if this vehicle is used to handle a shipment."
        },
        "used_if_route_is_empty": {
          "type": "bool",
          "description": "This field only applies to vehicles when their route does not serve any shipments. It indicates if the vehicle should be considered as used or not in this case.  If true, the vehicle goes from its start to its end location even if it doesn't serve any shipments, and time and distance costs resulting from its start --> end travel are taken into account.  Otherwise, it doesn't travel from its start to its end location, and no ``break_rule`` or delay (from ``TransitionAttributes``) are scheduled for this vehicle. In this case, the vehicle's ``ShipmentRoute`` doesn't contain any information except for the vehicle index and label."
        },
        "route_duration_limit": {
          "type": "google.cloud.optimization_v1.types.Vehicle.DurationLimit",
          "description": "Limit applied to the total duration of the vehicle's route. In a given ``OptimizeToursResponse``, the route duration of a vehicle is the difference between its ``vehicle_end_time`` and ``vehicle_start_time``."
        },
        "travel_duration_limit": {
          "type": "google.cloud.optimization_v1.types.Vehicle.DurationLimit",
          "description": "Limit applied to the travel duration of the vehicle's route. In a given ``OptimizeToursResponse``, the route travel duration is the sum of all its [transitions.travel_duration][google.cloud.optimization.v1.ShipmentRoute.Transition.travel_duration]."
        },
        "route_distance_limit": {
          "type": "google.cloud.optimization_v1.types.DistanceLimit",
          "description": "Limit applied to the total distance of the vehicle's route. In a given ``OptimizeToursResponse``, the route distance is the sum of all its [transitions.travel_distance_meters][google.cloud.optimization.v1.ShipmentRoute.Transition.travel_distance_meters]."
        },
        "extra_visit_duration_for_visit_type": {
          "type": "MutableMapping[str, google.protobuf.duration_pb2.Duration]",
          "description": "Specifies a map from visit_types strings to durations. The duration is time in addition to [VisitRequest.duration][google.cloud.optimization.v1.Shipment.VisitRequest.duration] to be taken at visits with the specified ``visit_types``. This extra visit duration adds cost if ``cost_per_hour`` is specified. Keys (i.e. ``visit_types``) cannot be empty strings.  If a visit request has multiple types, a duration will be added for each type in the map."
        },
        "break_rule": {
          "type": "google.cloud.optimization_v1.types.BreakRule",
          "description": "Describes the break schedule to be enforced on this vehicle. If empty, no breaks will be scheduled for this vehicle."
        },
        "label": {
          "type": "str",
          "description": "Specifies a label for this vehicle. This label is reported in the response as the ``vehicle_label`` of the corresponding [ShipmentRoute][google.cloud.optimization.v1.ShipmentRoute]."
        },
        "ignore": {
          "type": "bool",
          "description": "If true, ``used_if_route_is_empty`` must be false, and this vehicle will remain unused.  If a shipment is performed by an ignored vehicle in ``injected_first_solution_routes``, it is skipped in the first solution but is free to be performed in the response.  If a shipment is performed by an ignored vehicle in ``injected_solution_constraint`` and any related pickup/delivery is constrained to remain on the vehicle (i.e., not relaxed to level ``RELAX_ALL_AFTER_THRESHOLD``), it is skipped in the response. If a shipment has a non-empty ``allowed_vehicle_indices`` field and all of the allowed vehicles are ignored, it is skipped in the response."
        },
        "break_rule_indices": {
          "type": "MutableSequence[int]",
          "description": "Deprecated: No longer used. Indices in the ``break_rule`` field in the source [ShipmentModel][google.cloud.optimization.v1.ShipmentModel]. They correspond to break rules enforced on the vehicle.  As of 2018/03, at most one rule index per vehicle can be specified."
        },
        "capacities": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.CapacityQuantity]",
          "description": "Deprecated: Use [Vehicle.load_limits][google.cloud.optimization.v1.Vehicle.load_limits] instead."
        },
        "start_load_intervals": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.CapacityQuantityInterval]",
          "description": "Deprecated: Use [Vehicle.LoadLimit.start_load_interval][google.cloud.optimization.v1.Vehicle.LoadLimit.start_load_interval] instead."
        },
        "end_load_intervals": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.CapacityQuantityInterval]",
          "description": "Deprecated: Use [Vehicle.LoadLimit.end_load_interval][google.cloud.optimization.v1.Vehicle.LoadLimit.end_load_interval] instead."
        }
      }
    },
    {
      "type": "request_class",
      "name": "TimeWindow",
      "docstring": "Time windows constrain the time of an event, such as the arrival\ntime at a visit, or the start and end time of a vehicle.\n\nHard time window bounds, ``start_time`` and ``end_time``, enforce\nthe earliest and latest time of the event, such that\n``start_time <= event_time <= end_time``. The soft time window lower\nbound, ``soft_start_time``, expresses a preference for the event to\nhappen at or after ``soft_start_time`` by incurring a cost\nproportional to how long before soft_start_time the event occurs.\nThe soft time window upper bound, ``soft_end_time``, expresses a\npreference for the event to happen at or before ``soft_end_time`` by\nincurring a cost proportional to how long after ``soft_end_time``\nthe event occurs. ``start_time``, ``end_time``, ``soft_start_time``\nand ``soft_end_time`` should be within the global time limits (see\n[ShipmentModel.global_start_time][google.cloud.optimization.v1.ShipmentModel.global_start_time]\nand\n[ShipmentModel.global_end_time][google.cloud.optimization.v1.ShipmentModel.global_end",
      "attributes": {
        "start_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "The hard time window start time. If unspecified it will be set to ``ShipmentModel.global_start_time``."
        },
        "end_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "The hard time window end time. If unspecified it will be set to ``ShipmentModel.global_end_time``."
        },
        "soft_start_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "The soft start time of the time window."
        },
        "soft_end_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "The soft end time of the time window."
        },
        "cost_per_hour_before_soft_start_time": {
          "type": "float",
          "description": "A cost per hour added to other costs in the model if the event occurs before soft_start_time, computed as:  ::  max(0, soft_start_time - t.seconds) * cost_per_hour_before_soft_start_time / 3600, t being the time of the event.  This cost must be positive, and the field can only be set if soft_start_time has been set.  This field is a member of `oneof`_ ``_cost_per_hour_before_soft_start_time``."
        },
        "cost_per_hour_after_soft_end_time": {
          "type": "float",
          "description": "A cost per hour added to other costs in the model if the event occurs after ``soft_end_time``, computed as:  ::  max(0, t.seconds - soft_end_time.seconds) * cost_per_hour_after_soft_end_time / 3600, t being the time of the event.  This cost must be positive, and the field can only be set if ``soft_end_time`` has been set.  This field is a member of `oneof`_ ``_cost_per_hour_after_soft_end_time``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "CapacityQuantity",
      "docstring": "Deprecated: Use\n[Vehicle.LoadLimit.Interval][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval]\ninstead.\n\nAttributes:\n    type_ (str):\n\n    value (int):",
      "attributes": {
        "type_": {
          "type": "str",
          "description": ""
        },
        "value": {
          "type": "int",
          "description": ""
        }
      }
    },
    {
      "type": "request_class",
      "name": "CapacityQuantityInterval",
      "docstring": "Deprecated: Use\n[Vehicle.LoadLimit.Interval][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval]\ninstead.\n\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    type_ (str):\n\n    min_value (int):\n\n        This field is a member of `oneof`_ ``_min_value``.\n    max_value (int):\n\n        This field is a member of `oneof`_ ``_max_value``.",
      "attributes": {
        "type_": {
          "type": "str",
          "description": ""
        },
        "min_value": {
          "type": "int",
          "description": "This field is a member of `oneof`_ ``_min_value``."
        },
        "max_value": {
          "type": "int",
          "description": "This field is a member of `oneof`_ ``_max_value``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "DistanceLimit",
      "docstring": "A limit defining a maximum distance which can be traveled. It can be\neither hard or soft.\n\nIf a soft limit is defined, both ``soft_max_meters`` and\n``cost_per_kilometer_above_soft_max`` must be defined and be\nnonnegative.\n\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    max_meters (int):\n        A hard limit constraining the distance to be at most\n        max_meters. The limit must be nonnegative.\n\n        This field is a member of `oneof`_ ``_max_meters``.\n    soft_max_meters (int):\n        A soft limit not enforcing a maximum distance limit, but\n        when violated results in a cost which adds up to other costs\n        defined in the model, with the same unit.\n\n        If defined soft_max_meters must be less than max_meters and\n        must be nonnegative.\n\n        This field is a member of `oneof`_ ``_soft_max_meters``.\n    cost_per_kilometer_below_soft_max (float):\n        Cost per kilometer incurred, increasing up to\n        `",
      "attributes": {
        "max_meters": {
          "type": "int",
          "description": "A hard limit constraining the distance to be at most max_meters. The limit must be nonnegative.  This field is a member of `oneof`_ ``_max_meters``."
        },
        "soft_max_meters": {
          "type": "int",
          "description": "A soft limit not enforcing a maximum distance limit, but when violated results in a cost which adds up to other costs defined in the model, with the same unit.  If defined soft_max_meters must be less than max_meters and must be nonnegative.  This field is a member of `oneof`_ ``_soft_max_meters``."
        },
        "cost_per_kilometer_below_soft_max": {
          "type": "float",
          "description": "Cost per kilometer incurred, increasing up to ``soft_max_meters``, with formula:  ::  min(distance_meters, soft_max_meters) / 1000.0 * cost_per_kilometer_below_soft_max.  This cost is not supported in ``route_distance_limit``.  This field is a member of `oneof`_ ``_cost_per_kilometer_below_soft_max``."
        },
        "cost_per_kilometer_above_soft_max": {
          "type": "float",
          "description": "Cost per kilometer incurred if distance is above ``soft_max_meters`` limit. The additional cost is 0 if the distance is under the limit, otherwise the formula used to compute the cost is the following:  ::  (distance_meters - soft_max_meters) / 1000.0 * cost_per_kilometer_above_soft_max.  The cost must be nonnegative.  This field is a member of `oneof`_ ``_cost_per_kilometer_above_soft_max``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "TransitionAttributes",
      "docstring": "Specifies attributes of transitions between two consecutive visits\non a route. Several ``TransitionAttributes`` may apply to the same\ntransition: in that case, all extra costs add up and the strictest\nconstraint or limit applies (following natural \"AND\" semantics).\n\nAttributes:\n    src_tag (str):\n        Tags defining the set of (src->dst) transitions these\n        attributes apply to.\n\n        A source visit or vehicle start matches iff its\n        [VisitRequest.tags][google.cloud.optimization.v1.Shipment.VisitRequest.tags]\n        or\n        [Vehicle.start_tags][google.cloud.optimization.v1.Vehicle.start_tags]\n        either contains ``src_tag`` or does not contain\n        ``excluded_src_tag`` (depending on which of these two fields\n        is non-empty).\n    excluded_src_tag (str):\n        See ``src_tag``. Exactly one of ``src_tag`` and\n        ``excluded_src_tag`` must be non-empty.\n    dst_tag (str):\n        A destination visit or vehicle end matches iff its\n        [VisitRequest.tags][google.cloud.optim",
      "attributes": {
        "src_tag": {
          "type": "str",
          "description": "Tags defining the set of (src->dst) transitions these attributes apply to.  A source visit or vehicle start matches iff its [VisitRequest.tags][google.cloud.optimization.v1.Shipment.VisitRequest.tags] or [Vehicle.start_tags][google.cloud.optimization.v1.Vehicle.start_tags] either contains ``src_tag`` or does not contain ``excluded_src_tag`` (depending on which of these two fields is non-empty)."
        },
        "excluded_src_tag": {
          "type": "str",
          "description": "See ``src_tag``. Exactly one of ``src_tag`` and ``excluded_src_tag`` must be non-empty."
        },
        "dst_tag": {
          "type": "str",
          "description": "A destination visit or vehicle end matches iff its [VisitRequest.tags][google.cloud.optimization.v1.Shipment.VisitRequest.tags] or [Vehicle.end_tags][google.cloud.optimization.v1.Vehicle.end_tags] either contains ``dst_tag`` or does not contain ``excluded_dst_tag`` (depending on which of these two fields is non-empty)."
        },
        "excluded_dst_tag": {
          "type": "str",
          "description": "See ``dst_tag``. Exactly one of ``dst_tag`` and ``excluded_dst_tag`` must be non-empty."
        },
        "cost": {
          "type": "float",
          "description": "Specifies a cost for performing this transition. This is in the same unit as all other costs in the model and must not be negative. It is applied on top of all other existing costs."
        },
        "cost_per_kilometer": {
          "type": "float",
          "description": "Specifies a cost per kilometer applied to the distance traveled while performing this transition. It adds up to any [Vehicle.cost_per_kilometer][google.cloud.optimization.v1.Vehicle.cost_per_kilometer] specified on vehicles."
        },
        "distance_limit": {
          "type": "google.cloud.optimization_v1.types.DistanceLimit",
          "description": "Specifies a limit on the distance traveled while performing this transition.  As of 2021/06, only soft limits are supported."
        },
        "delay": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Specifies a delay incurred when performing this transition.  This delay always occurs *after* finishing the source visit and *before* starting the destination visit."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Waypoint",
      "docstring": "Encapsulates a waypoint. Waypoints mark arrival and departure\nlocations of VisitRequests, and start and end locations of\nVehicles.\n\nThis message has `oneof`_ fields (mutually exclusive fields).\nFor each oneof, at most one member field can be set at the same time.\nSetting any member of the oneof automatically clears all other\nmembers.\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    location (google.cloud.optimization_v1.types.Location):\n        A point specified using geographic\n        coordinates, including an optional heading.\n\n        This field is a member of `oneof`_ ``location_type``.\n    place_id (str):\n        The POI Place ID associated with the\n        waypoint.\n\n        This field is a member of `oneof`_ ``location_type``.\n    side_of_road (bool):\n        Indicates that the location of this waypoint is meant to\n        have a preference for the vehicle to stop at a particular\n        side of road. When you set this value, ",
      "attributes": {
        "location": {
          "type": "google.cloud.optimization_v1.types.Location",
          "description": "A point specified using geographic coordinates, including an optional heading.  This field is a member of `oneof`_ ``location_type``."
        },
        "place_id": {
          "type": "str",
          "description": "The POI Place ID associated with the waypoint.  This field is a member of `oneof`_ ``location_type``."
        },
        "side_of_road": {
          "type": "bool",
          "description": "Indicates that the location of this waypoint is meant to have a preference for the vehicle to stop at a particular side of road. When you set this value, the route will pass through the location so that the vehicle can stop at the side of road that the location is biased towards from the center of the road. This option works only for the 'DRIVING' travel mode, and when the 'location_type' is set to 'location'."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Location",
      "docstring": "Encapsulates a location (a geographic point, and an optional\nheading).\n\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    lat_lng (google.type.latlng_pb2.LatLng):\n        The waypoint's geographic coordinates.\n    heading (int):\n        The compass heading associated with the\n        direction of the flow of traffic. This value is\n        used to specify the side of the road to use for\n        pickup and drop-off. Heading values can be from\n        0 to 360, where 0 specifies a heading of due\n        North, 90 specifies a heading of due East, etc.\n\n        This field is a member of `oneof`_ ``_heading``.",
      "attributes": {
        "lat_lng": {
          "type": "google.type.latlng_pb2.LatLng",
          "description": "The waypoint's geographic coordinates."
        },
        "heading": {
          "type": "int",
          "description": "The compass heading associated with the direction of the flow of traffic. This value is used to specify the side of the road to use for pickup and drop-off. Heading values can be from 0 to 360, where 0 specifies a heading of due North, 90 specifies a heading of due East, etc.  This field is a member of `oneof`_ ``_heading``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "BreakRule",
      "docstring": "Rules to generate time breaks for a vehicle (e.g. lunch breaks). A\nbreak is a contiguous period of time during which the vehicle\nremains idle at its current position and cannot perform any visit. A\nbreak may occur:\n\n-  during the travel between two visits (which includes the time\n   right before or right after a visit, but not in the middle of a\n   visit), in which case it extends the corresponding transit time\n   between the visits,\n-  or before the vehicle start (the vehicle may not start in the\n   middle of a break), in which case it does not affect the vehicle\n   start time.\n-  or after the vehicle end (ditto, with the vehicle end time).\n\nAttributes:\n    break_requests (MutableSequence[google.cloud.optimization_v1.types.BreakRule.BreakRequest]):\n        Sequence of breaks. See the ``BreakRequest`` message.\n    frequency_constraints (MutableSequence[google.cloud.optimization_v1.types.BreakRule.FrequencyConstraint]):\n        Several ``FrequencyConstraint`` may apply. They must all be\n        satisfied by th",
      "attributes": {
        "break_requests": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.BreakRule.BreakRequest]",
          "description": "Sequence of breaks. See the ``BreakRequest`` message."
        },
        "frequency_constraints": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.BreakRule.FrequencyConstraint]",
          "description": "Several ``FrequencyConstraint`` may apply. They must all be satisfied by the ``BreakRequest``\\ s of this ``BreakRule``. See ``FrequencyConstraint``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ShipmentRoute",
      "docstring": "A vehicle's route can be decomposed, along the time axis, like this\n(we assume there are n visits):\n\n::\n\n     |            |            |          |       |  T[2], |        |      |\n     | Transition |  Visit #0  |          |       |  V[2], |        |      |\n     |     #0     |    aka     |   T[1]   |  V[1] |  ...   | V[n-1] | T[n] |\n     |  aka T[0]  |    V[0]    |          |       | V[n-2],|        |      |\n     |            |            |          |       | T[n-1] |        |      |\n     ^            ^            ^          ^       ^        ^        ^      ^\n   vehicle    V[0].start   V[0].end     V[1].   V[1].    V[n].    V[n]. vehicle\n    start     (arrival)   (departure)   start   end      start    end     end\n\nNote that we make a difference between:\n\n-  \"punctual events\", such as the vehicle start and end and each\n   visit's start and end (aka arrival and departure). They happen at\n   a given second.\n-  \"time intervals\", such as the visits themselves, and the\n   transition between visits. Though time in",
      "attributes": {
        "vehicle_index": {
          "type": "int",
          "description": "Vehicle performing the route, identified by its index in the source ``ShipmentModel``."
        },
        "vehicle_label": {
          "type": "str",
          "description": "Label of the vehicle performing this route, equal to ``ShipmentModel.vehicles(vehicle_index).label``, if specified."
        },
        "vehicle_start_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Time at which the vehicle starts its route."
        },
        "vehicle_end_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Time at which the vehicle finishes its route."
        },
        "visits": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentRoute.Visit]",
          "description": "Ordered sequence of visits representing a route. visits[i] is the i-th visit in the route. If this field is empty, the vehicle is considered as unused."
        },
        "transitions": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentRoute.Transition]",
          "description": "Ordered list of transitions for the route."
        },
        "has_traffic_infeasibilities": {
          "type": "bool",
          "description": "When [OptimizeToursRequest.consider_road_traffic][google.cloud.optimization.v1.OptimizeToursRequest.consider_road_traffic], is set to true, this field indicates that inconsistencies in route timings are predicted using traffic-based travel duration estimates. There may be insufficient time to complete traffic-adjusted travel, delays, and breaks between visits, before the first visit, or after the last visit, while still satisfying the visit and vehicle time windows. For example,  ::  start_time(previous_visit) + duration(previous_visit) + travel_duration(previous_visit, next_visit) > start_time(next_visit)  Arrival at next_visit will likely happen later than its current time window due the increased estimate of travel time ``travel_duration(previous_visit, next_visit)`` due to traffic. Also, a break may be forced to overlap with a visit due to an increase in travel time estimates and visit or break time window restrictions."
        },
        "route_polyline": {
          "type": "google.cloud.optimization_v1.types.ShipmentRoute.EncodedPolyline",
          "description": "The encoded polyline representation of the route. This field is only populated if [OptimizeToursRequest.populate_polylines][google.cloud.optimization.v1.OptimizeToursRequest.populate_polylines] is set to true."
        },
        "breaks": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentRoute.Break]",
          "description": "Breaks scheduled for the vehicle performing this route. The ``breaks`` sequence represents time intervals, each starting at the corresponding ``start_time`` and lasting ``duration`` seconds."
        },
        "metrics": {
          "type": "google.cloud.optimization_v1.types.AggregatedMetrics",
          "description": "Duration, distance and load metrics for this route. The fields of [AggregatedMetrics][google.cloud.optimization.v1.AggregatedMetrics] are summed over all [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions] or [ShipmentRoute.visits][google.cloud.optimization.v1.ShipmentRoute.visits], depending on the context."
        },
        "route_costs": {
          "type": "MutableMapping[str, float]",
          "description": "Cost of the route, broken down by cost-related request fields. The keys are proto paths, relative to the input OptimizeToursRequest, e.g. \"model.shipments.pickups.cost\", and the values are the total cost generated by the corresponding cost field, aggregated over the whole route. In other words, costs[\"model.shipments.pickups.cost\"] is the sum of all pickup costs over the route. All costs defined in the model are reported in detail here with the exception of costs related to TransitionAttributes that are only reported in an aggregated way as of 2022/01."
        },
        "route_total_cost": {
          "type": "float",
          "description": "Total cost of the route. The sum of all costs in the cost map."
        },
        "end_loads": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.CapacityQuantity]",
          "description": "Deprecated: Use [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads] instead. Vehicle loads upon arrival at its end location, for each type specified in [Vehicle.capacities][google.cloud.optimization.v1.Vehicle.capacities], ``start_load_intervals``, ``end_load_intervals`` or demands. Exception: we omit loads for quantity types unconstrained by intervals and that don't have any non-zero demand on the route."
        },
        "travel_steps": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentRoute.TravelStep]",
          "description": "Deprecated: Use [ShipmentRoute.transitions][google.cloud.optimization.v1.ShipmentRoute.transitions] instead. Ordered list of travel steps for the route."
        },
        "vehicle_detour": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Deprecated: No longer used. This field will only be populated at the [ShipmentRoute.Visit][google.cloud.optimization.v1.ShipmentRoute.Visit] level.  This field is the extra detour time due to the shipments visited on the route.  It is equal to ``vehicle_end_time`` - ``vehicle_start_time`` - travel duration from the vehicle's start_location to its ``end_location``."
        },
        "delay_before_vehicle_end": {
          "type": "google.cloud.optimization_v1.types.ShipmentRoute.Delay",
          "description": "Deprecated: Delay occurring before the vehicle end. See [TransitionAttributes.delay][google.cloud.optimization.v1.TransitionAttributes.delay]."
        }
      }
    },
    {
      "type": "request_class",
      "name": "SkippedShipment",
      "docstring": "Specifies details of unperformed shipments in a solution. For\ntrivial cases and/or if we are able to identify the cause for\nskipping, we report the reason here.\n\nAttributes:\n    index (int):\n        The index corresponds to the index of the shipment in the\n        source ``ShipmentModel``.\n    label (str):\n        Copy of the corresponding\n        [Shipment.label][google.cloud.optimization.v1.Shipment.label],\n        if specified in the ``Shipment``.\n    reasons (MutableSequence[google.cloud.optimization_v1.types.SkippedShipment.Reason]):\n        A list of reasons that explain why the shipment was skipped.\n        See comment above ``Reason``.",
      "attributes": {
        "index": {
          "type": "int",
          "description": "The index corresponds to the index of the shipment in the source ``ShipmentModel``."
        },
        "label": {
          "type": "str",
          "description": "Copy of the corresponding [Shipment.label][google.cloud.optimization.v1.Shipment.label], if specified in the ``Shipment``."
        },
        "reasons": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.SkippedShipment.Reason]",
          "description": "A list of reasons that explain why the shipment was skipped. See comment above ``Reason``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "AggregatedMetrics",
      "docstring": "Aggregated metrics for\n[ShipmentRoute][google.cloud.optimization.v1.ShipmentRoute] (resp.\nfor\n[OptimizeToursResponse][google.cloud.optimization.v1.OptimizeToursResponse]\nover all\n[Transition][google.cloud.optimization.v1.ShipmentRoute.Transition]\nand/or [Visit][google.cloud.optimization.v1.ShipmentRoute.Visit]\n(resp. over all\n[ShipmentRoute][google.cloud.optimization.v1.ShipmentRoute])\nelements.\n\nAttributes:\n    performed_shipment_count (int):\n        Number of shipments performed. Note that a\n        pickup and delivery pair only counts once.\n    travel_duration (google.protobuf.duration_pb2.Duration):\n        Total travel duration for a route or a\n        solution.\n    wait_duration (google.protobuf.duration_pb2.Duration):\n        Total wait duration for a route or a\n        solution.\n    delay_duration (google.protobuf.duration_pb2.Duration):\n        Total delay duration for a route or a\n        solution.\n    break_duration (google.protobuf.duration_pb2.Duration):\n        Total break duration for a route o",
      "attributes": {
        "performed_shipment_count": {
          "type": "int",
          "description": "Number of shipments performed. Note that a pickup and delivery pair only counts once."
        },
        "travel_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Total travel duration for a route or a solution."
        },
        "wait_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Total wait duration for a route or a solution."
        },
        "delay_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Total delay duration for a route or a solution."
        },
        "break_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Total break duration for a route or a solution."
        },
        "visit_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Total visit duration for a route or a solution."
        },
        "total_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "The total duration should be equal to the sum of all durations above. For routes, it also corresponds to: [ShipmentRoute.vehicle_end_time][google.cloud.optimization.v1.ShipmentRoute.vehicle_end_time] ``-`` [ShipmentRoute.vehicle_start_time][google.cloud.optimization.v1.ShipmentRoute.vehicle_start_time]"
        },
        "travel_distance_meters": {
          "type": "float",
          "description": "Total travel distance for a route or a solution."
        },
        "max_loads": {
          "type": "MutableMapping[str, google.cloud.optimization_v1.types.ShipmentRoute.VehicleLoad]",
          "description": "Maximum load achieved over the entire route (resp. solution), for each of the quantities on this route (resp. solution), computed as the maximum over all [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads] (resp. [ShipmentRoute.metrics.max_loads][google.cloud.optimization.v1.AggregatedMetrics.max_loads]."
        },
        "costs": {
          "type": "MutableMapping[str, float]",
          "description": "Deprecated: Use [ShipmentRoute.route_costs][google.cloud.optimization.v1.ShipmentRoute.route_costs] and [OptimizeToursResponse.Metrics.costs][google.cloud.optimization.v1.OptimizeToursResponse.Metrics.costs] instead."
        },
        "total_cost": {
          "type": "float",
          "description": "Deprecated: Use [ShipmentRoute.route_total_cost][google.cloud.optimization.v1.ShipmentRoute.route_total_cost] and [OptimizeToursResponse.Metrics.total_cost][google.cloud.optimization.v1.OptimizeToursResponse.Metrics.total_cost] instead."
        }
      }
    },
    {
      "type": "request_class",
      "name": "InjectedSolutionConstraint",
      "docstring": "Solution injected in the request including information about\nwhich visits must be constrained and how they must be\nconstrained.\n\nAttributes:\n    routes (MutableSequence[google.cloud.optimization_v1.types.ShipmentRoute]):\n        Routes of the solution to inject. Some routes may be omitted\n        from the original solution. The routes and skipped shipments\n        must satisfy the basic validity assumptions listed for\n        ``injected_first_solution_routes``.\n    skipped_shipments (MutableSequence[google.cloud.optimization_v1.types.SkippedShipment]):\n        Skipped shipments of the solution to inject. Some may be\n        omitted from the original solution. See the ``routes``\n        field.\n    constraint_relaxations (MutableSequence[google.cloud.optimization_v1.types.InjectedSolutionConstraint.ConstraintRelaxation]):\n        For zero or more groups of vehicles,\n        specifies when and how much to relax\n        constraints. If this field is empty, all\n        non-empty vehicle routes are fully constraine",
      "attributes": {
        "routes": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentRoute]",
          "description": "Routes of the solution to inject. Some routes may be omitted from the original solution. The routes and skipped shipments must satisfy the basic validity assumptions listed for ``injected_first_solution_routes``."
        },
        "skipped_shipments": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.SkippedShipment]",
          "description": "Skipped shipments of the solution to inject. Some may be omitted from the original solution. See the ``routes`` field."
        },
        "constraint_relaxations": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.InjectedSolutionConstraint.ConstraintRelaxation]",
          "description": "For zero or more groups of vehicles, specifies when and how much to relax constraints. If this field is empty, all non-empty vehicle routes are fully constrained."
        }
      }
    },
    {
      "type": "request_class",
      "name": "OptimizeToursValidationError",
      "docstring": "Describes an error encountered when validating an\n``OptimizeToursRequest``.\n\nAttributes:\n    code (int):\n        A validation error is defined by the pair (``code``,\n        ``display_name``) which are always present.\n\n        Other fields (below) provide more context about the error.\n\n        *MULTIPLE ERRORS*: When there are multiple errors, the\n        validation process tries to output several of them. Much\n        like a compiler, this is an imperfect process. Some\n        validation errors will be \"fatal\", meaning that they stop\n        the entire validation process. This is the case for\n        ``display_name=\"UNSPECIFIED\"`` errors, among others. Some\n        may cause the validation process to skip other errors.\n\n        *STABILITY*: ``code`` and ``display_name`` should be very\n        stable. But new codes and display names may appear over\n        time, which may cause a given (invalid) request to yield a\n        different (``code``, ``display_name``) pair because the new\n        error hid the old on",
      "attributes": {
        "code": {
          "type": "int",
          "description": "A validation error is defined by the pair (``code``, ``display_name``) which are always present.  Other fields (below) provide more context about the error.  *MULTIPLE ERRORS*: When there are multiple errors, the validation process tries to output several of them. Much like a compiler, this is an imperfect process. Some validation errors will be \"fatal\", meaning that they stop the entire validation process. This is the case for ``display_name=\"UNSPECIFIED\"`` errors, among others. Some may cause the validation process to skip other errors.  *STABILITY*: ``code`` and ``display_name`` should be very stable. But new codes and display names may appear over time, which may cause a given (invalid) request to yield a different (``code``, ``display_name``) pair because the new error hid the old one (see \"MULTIPLE ERRORS\").  *REFERENCE*: A list of all (code, name) pairs:  -  UNSPECIFIED = 0;  -  VALIDATION_TIMEOUT_ERROR = 10; Validation couldn't be completed within the deadline.  -  REQUEST_OPTIONS_ERROR = 12;  -  REQUEST_OPTIONS_INVALID_SOLVING_MODE = 1201; -  REQUEST_OPTIONS_INVALID_MAX_VALIDATION_ERRORS = 1203; -  REQUEST_OPTIONS_INVALID_GEODESIC_METERS_PER_SECOND = 1204; -  REQUEST_OPTIONS_GEODESIC_METERS_PER_SECOND_TOO_SMALL = 1205; -  REQUEST_OPTIONS_MISSING_GEODESIC_METERS_PER_SECOND = 1206; -  REQUEST_OPTIONS_POPULATE_PATHFINDER_TRIPS_AND_GEODESIC_DISTANCE = 1207; -  REQUEST_OPTIONS_COST_MODEL_OPTIONS_AND_GEODESIC_DISTANCE = 1208; -  REQUEST_OPTIONS_TRAVEL_MODE_INCOMPATIBLE_WITH_TRAFFIC = 1211; -  REQUEST_OPTIONS_MULTIPLE_TRAFFIC_FLAVORS = 1212; -  REQUEST_OPTIONS_INVALID_TRAFFIC_FLAVOR = 1213; -  REQUEST_OPTIONS_TRAFFIC_ENABLED_WITHOUT_GLOBAL_START_TIME = 1214; -  REQUEST_OPTIONS_TRAFFIC_ENABLED_WITH_PRECEDENCES = 1215; -  REQUEST_OPTIONS_TRAFFIC_PREFILL_MODE_INVALID = 1216; -  REQUEST_OPTIONS_TRAFFIC_PREFILL_ENABLED_WITHOUT_TRAFFIC = 1217;  -  INJECTED_SOLUTION_ERROR = 20;  -  INJECTED_SOLUTION_MISSING_LABEL = 2000; -  INJECTED_SOLUTION_DUPLICATE_LABEL = 2001; -  INJECTED_SOLUTION_AMBIGUOUS_INDEX = 2002; -  INJECTED_SOLUTION_INFEASIBLE_AFTER_GETTING_TRAVEL_TIMES = 2003; -  INJECTED_SOLUTION_TRANSITION_INCONSISTENT_WITH_ACTUAL_TRAVEL = 2004; -  INJECTED_SOLUTION_CONCURRENT_SOLUTION_TYPES = 2005; -  INJECTED_SOLUTION_MORE_THAN_ONE_PER_TYPE = 2006; -  INJECTED_SOLUTION_REFRESH_WITHOUT_POPULATE = 2008; -  INJECTED_SOLUTION_CONSTRAINED_ROUTE_PORTION_INFEASIBLE = 2010;  -  SHIPMENT_MODEL_ERROR = 22;  -  SHIPMENT_MODEL_TOO_LARGE = 2200; -  SHIPMENT_MODEL_TOO_MANY_CAPACITY_TYPES = 2201; -  SHIPMENT_MODEL_GLOBAL_START_TIME_NEGATIVE_OR_NAN = 2202; -  SHIPMENT_MODEL_GLOBAL_END_TIME_TOO_LARGE_OR_NAN = 2203; -  SHIPMENT_MODEL_GLOBAL_START_TIME_AFTER_GLOBAL_END_TIME = 2204; -  SHIPMENT_MODEL_GLOBAL_DURATION_TOO_LONG = 2205; -  SHIPMENT_MODEL_MAX_ACTIVE_VEHICLES_NOT_POSITIVE = 2206; -  SHIPMENT_MODEL_DURATION_MATRIX_TOO_LARGE = 2207;  -  INDEX_ERROR = 24;  -  TAG_ERROR = 26;  -  TIME_WINDOW_ERROR = 28;  -  TIME_WINDOW_INVALID_START_TIME = 2800; -  TIME_WINDOW_INVALID_END_TIME = 2801; -  TIME_WINDOW_INVALID_SOFT_START_TIME = 2802; -  TIME_WINDOW_INVALID_SOFT_END_TIME = 2803; -  TIME_WINDOW_OUTSIDE_GLOBAL_TIME_WINDOW = 2804; -  TIME_WINDOW_START_TIME_AFTER_END_TIME = 2805; -  TIME_WINDOW_INVALID_COST_PER_HOUR_BEFORE_SOFT_START_TIME = 2806; -  TIME_WINDOW_INVALID_COST_PER_HOUR_AFTER_SOFT_END_TIME = 2807; -  TIME_WINDOW_COST_BEFORE_SOFT_START_TIME_WITHOUT_SOFT_START_TIME = 2808; -  TIME_WINDOW_COST_AFTER_SOFT_END_TIME_WITHOUT_SOFT_END_TIME = 2809; -  TIME_WINDOW_SOFT_START_TIME_WITHOUT_COST_BEFORE_SOFT_START_TIME = 2810; -  TIME_WINDOW_SOFT_END_TIME_WITHOUT_COST_AFTER_SOFT_END_TIME = 2811; -  TIME_WINDOW_OVERLAPPING_ADJACENT_OR_EARLIER_THAN_PREVIOUS = 2812; -  TIME_WINDOW_START_TIME_AFTER_SOFT_START_TIME = 2813; -  TIME_WINDOW_SOFT_START_TIME_AFTER_END_TIME = 2814; -  TIME_WINDOW_START_TIME_AFTER_SOFT_END_TIME = 2815; -  TIME_WINDOW_SOFT_END_TIME_AFTER_END_TIME = 2816; -  TIME_WINDOW_COST_BEFORE_SOFT_START_TIME_SET_AND_MULTIPLE_WINDOWS = 2817; -  TIME_WINDOW_COST_AFTER_SOFT_END_TIME_SET_AND_MULTIPLE_WINDOWS = 2818; -  TRANSITION_ATTRIBUTES_ERROR = 30; -  TRANSITION_ATTRIBUTES_INVALID_COST = 3000; -  TRANSITION_ATTRIBUTES_INVALID_COST_PER_KILOMETER = 3001; -  TRANSITION_ATTRIBUTES_DUPLICATE_TAG_PAIR = 3002; -  TRANSITION_ATTRIBUTES_DISTANCE_LIMIT_MAX_METERS_UNSUPPORTED = 3003; -  TRANSITION_ATTRIBUTES_UNSPECIFIED_SOURCE_TAGS = 3004; -  TRANSITION_ATTRIBUTES_CONFLICTING_SOURCE_TAGS_FIELDS = 3005; -  TRANSITION_ATTRIBUTES_UNSPECIFIED_DESTINATION_TAGS = 3006; -  TRANSITION_ATTRIBUTES_CONFLICTING_DESTINATION_TAGS_FIELDS = 3007; -  TRANSITION_ATTRIBUTES_DELAY_DURATION_NEGATIVE_OR_NAN = 3008; -  TRANSITION_ATTRIBUTES_DELAY_DURATION_EXCEEDS_GLOBAL_DURATION = 3009;  -  AMOUNT_ERROR = 31;  -  AMOUNT_NEGATIVE_VALUE = 3100;  -  LOAD_LIMIT_ERROR = 33;  -  LOAD_LIMIT_INVALID_COST_ABOVE_SOFT_MAX = 3303; -  LOAD_LIMIT_SOFT_MAX_WITHOUT_COST_ABOVE_SOFT_MAX = 3304; -  LOAD_LIMIT_COST_ABOVE_SOFT_MAX_WITHOUT_SOFT_MAX = 3305; -  LOAD_LIMIT_NEGATIVE_SOFT_MAX = 3306; -  LOAD_LIMIT_MIXED_DEMAND_TYPE = 3307; -  LOAD_LIMIT_MAX_LOAD_NEGATIVE_VALUE = 3308; -  LOAD_LIMIT_SOFT_MAX_ABOVE_MAX = 3309;  -  INTERVAL_ERROR = 34;  -  INTERVAL_MIN_EXCEEDS_MAX = 3401; -  INTERVAL_NEGATIVE_MIN = 3402; -  INTERVAL_NEGATIVE_MAX = 3403; -  INTERVAL_MIN_EXCEEDS_CAPACITY = 3404; -  INTERVAL_MAX_EXCEEDS_CAPACITY = 3405;  -  DISTANCE_LIMIT_ERROR = 36;  -  DISTANCE_LIMIT_INVALID_COST_AFTER_SOFT_MAX = 3601; -  DISTANCE_LIMIT_SOFT_MAX_WITHOUT_COST_AFTER_SOFT_MAX = 3602; -  DISTANCE_LIMIT_COST_AFTER_SOFT_MAX_WITHOUT_SOFT_MAX = 3603; -  DISTANCE_LIMIT_NEGATIVE_MAX = 3604; -  DISTANCE_LIMIT_NEGATIVE_SOFT_MAX = 3605; -  DISTANCE_LIMIT_SOFT_MAX_LARGER_THAN_MAX = 3606;  -  DURATION_LIMIT_ERROR = 38;  -  DURATION_LIMIT_MAX_DURATION_NEGATIVE_OR_NAN = 3800; -  DURATION_LIMIT_SOFT_MAX_DURATION_NEGATIVE_OR_NAN = 3801; -  DURATION_LIMIT_INVALID_COST_PER_HOUR_AFTER_SOFT_MAX = 3802; -  DURATION_LIMIT_SOFT_MAX_WITHOUT_COST_AFTER_SOFT_MAX = 3803; -  DURATION_LIMIT_COST_AFTER_SOFT_MAX_WITHOUT_SOFT_MAX = 3804; -  DURATION_LIMIT_QUADRATIC_SOFT_MAX_DURATION_NEGATIVE_OR_NAN = 3805; -  DURATION_LIMIT_INVALID_COST_AFTER_QUADRATIC_SOFT_MAX = 3806; -  DURATION_LIMIT_QUADRATIC_SOFT_MAX_WITHOUT_COST_PER_SQUARE_HOUR = 3807; -  DURATION_LIMIT_COST_PER_SQUARE_HOUR_WITHOUT_QUADRATIC_SOFT_MAX = 3808; -  DURATION_LIMIT_QUADRATIC_SOFT_MAX_WITHOUT_MAX = 3809; -  DURATION_LIMIT_SOFT_MAX_LARGER_THAN_MAX = 3810; -  DURATION_LIMIT_QUADRATIC_SOFT_MAX_LARGER_THAN_MAX = 3811; -  DURATION_LIMIT_DIFF_BETWEEN_MAX_AND_QUADRATIC_SOFT_MAX_TOO_LARGE = 3812; -  DURATION_LIMIT_MAX_DURATION_EXCEEDS_GLOBAL_DURATION = 3813; -  DURATION_LIMIT_SOFT_MAX_DURATION_EXCEEDS_GLOBAL_DURATION = 3814; -  DURATION_LIMIT_QUADRATIC_SOFT_MAX_DURATION_EXCEEDS_GLOBAL_DURATION = 3815;  -  SHIPMENT_ERROR = 40;  -  SHIPMENT_PD_LIMIT_WITHOUT_PICKUP_AND_DELIVERY = 4014; -  SHIPMENT_PD_ABSOLUTE_DETOUR_LIMIT_DURATION_NEGATIVE_OR_NAN = 4000; -  SHIPMENT_PD_ABSOLUTE_DETOUR_LIMIT_DURATION_EXCEEDS_GLOBAL_DURATION = 4001; -  SHIPMENT_PD_RELATIVE_DETOUR_LIMIT_INVALID = 4015; -  SHIPMENT_PD_DETOUR_LIMIT_AND_EXTRA_VISIT_DURATION = 4016; -  SHIPMENT_PD_TIME_LIMIT_DURATION_NEGATIVE_OR_NAN = 4002; -  SHIPMENT_PD_TIME_LIMIT_DURATION_EXCEEDS_GLOBAL_DURATION = 4003; -  SHIPMENT_EMPTY_SHIPMENT_TYPE = 4004; -  SHIPMENT_NO_PICKUP_NO_DELIVERY = 4005; -  SHIPMENT_INVALID_PENALTY_COST = 4006; -  SHIPMENT_ALLOWED_VEHICLE_INDEX_OUT_OF_BOUNDS = 4007; -  SHIPMENT_DUPLICATE_ALLOWED_VEHICLE_INDEX = 4008; -  SHIPMENT_INCONSISTENT_COST_FOR_VEHICLE_SIZE_WITHOUT_INDEX = 4009; -  SHIPMENT_INCONSISTENT_COST_FOR_VEHICLE_SIZE_WITH_INDEX = 4010; -  SHIPMENT_INVALID_COST_FOR_VEHICLE = 4011; -  SHIPMENT_COST_FOR_VEHICLE_INDEX_OUT_OF_BOUNDS = 4012; -  SHIPMENT_DUPLICATE_COST_FOR_VEHICLE_INDEX = 4013;  -  VEHICLE_ERROR = 42;  -  VEHICLE_EMPTY_REQUIRED_OPERATOR_TYPE = 4200; -  VEHICLE_DUPLICATE_REQUIRED_OPERATOR_TYPE = 4201; -  VEHICLE_NO_OPERATOR_WITH_REQUIRED_OPERATOR_TYPE = 4202; -  VEHICLE_EMPTY_START_TAG = 4203; -  VEHICLE_DUPLICATE_START_TAG = 4204; -  VEHICLE_EMPTY_END_TAG = 4205; -  VEHICLE_DUPLICATE_END_TAG = 4206; -  VEHICLE_EXTRA_VISIT_DURATION_NEGATIVE_OR_NAN = 4207; -  VEHICLE_EXTRA_VISIT_DURATION_EXCEEDS_GLOBAL_DURATION = 4208; -  VEHICLE_EXTRA_VISIT_DURATION_EMPTY_KEY = 4209; -  VEHICLE_FIRST_SHIPMENT_INDEX_OUT_OF_BOUNDS = 4210; -  VEHICLE_FIRST_SHIPMENT_IGNORED = 4211; -  VEHICLE_FIRST_SHIPMENT_NOT_BOUND = 4212; -  VEHICLE_LAST_SHIPMENT_INDEX_OUT_OF_BOUNDS = 4213; -  VEHICLE_LAST_SHIPMENT_IGNORED = 4214; -  VEHICLE_LAST_SHIPMENT_NOT_BOUND = 4215; -  VEHICLE_IGNORED_WITH_USED_IF_ROUTE_IS_EMPTY = 4216; -  VEHICLE_INVALID_COST_PER_KILOMETER = 4217; -  VEHICLE_INVALID_COST_PER_HOUR = 4218; -  VEHICLE_INVALID_COST_PER_TRAVELED_HOUR = 4219; -  VEHICLE_INVALID_FIXED_COST = 4220; -  VEHICLE_INVALID_TRAVEL_DURATION_MULTIPLE = 4221; -  VEHICLE_TRAVEL_DURATION_MULTIPLE_WITH_SHIPMENT_PD_DETOUR_LIMITS = 4223; -  VEHICLE_MATRIX_INDEX_WITH_SHIPMENT_PD_DETOUR_LIMITS = 4224; -  VEHICLE_MINIMUM_DURATION_LONGER_THAN_DURATION_LIMIT = 4222;  -  VISIT_REQUEST_ERROR = 44;  -  VISIT_REQUEST_EMPTY_TAG = 4400; -  VISIT_REQUEST_DUPLICATE_TAG = 4401; -  VISIT_REQUEST_DURATION_NEGATIVE_OR_NAN = 4404; -  VISIT_REQUEST_DURATION_EXCEEDS_GLOBAL_DURATION = 4405;  -  PRECEDENCE_ERROR = 46;  -  PRECEDENCE_RULE_MISSING_FIRST_INDEX = 4600; -  PRECEDENCE_RULE_MISSING_SECOND_INDEX = 4601; -  PRECEDENCE_RULE_FIRST_INDEX_OUT_OF_BOUNDS = 4602; -  PRECEDENCE_RULE_SECOND_INDEX_OUT_OF_BOUNDS = 4603; -  PRECEDENCE_RULE_DUPLICATE_INDEX = 4604; -  PRECEDENCE_RULE_INEXISTENT_FIRST_VISIT_REQUEST = 4605; -  PRECEDENCE_RULE_INEXISTENT_SECOND_VISIT_REQUEST = 4606;  -  BREAK_ERROR = 48;  -  BREAK_RULE_EMPTY = 4800; -  BREAK_REQUEST_UNSPECIFIED_DURATION = 4801; -  BREAK_REQUEST_UNSPECIFIED_EARLIEST_START_TIME = 4802; -  BREAK_REQUEST_UNSPECIFIED_LATEST_START_TIME = 4803; -  BREAK_REQUEST_DURATION_NEGATIVE_OR_NAN = 4804; = 4804; -  BREAK_REQUEST_LATEST_START_TIME_BEFORE_EARLIEST_START_TIME = 4805; -  BREAK_REQUEST_EARLIEST_START_TIME_BEFORE_GLOBAL_START_TIME = 4806; -  BREAK_REQUEST_LATEST_END_TIME_AFTER_GLOBAL_END_TIME = 4807; -  BREAK_REQUEST_NON_SCHEDULABLE = 4808; -  BREAK_FREQUENCY_MAX_INTER_BREAK_DURATION_NEGATIVE_OR_NAN = 4809; -  BREAK_FREQUENCY_MIN_BREAK_DURATION_NEGATIVE_OR_NAN = 4810; -  BREAK_FREQUENCY_MIN_BREAK_DURATION_EXCEEDS_GLOBAL_DURATION = 4811; -  BREAK_FREQUENCY_MAX_INTER_BREAK_DURATION_EXCEEDS_GLOBAL_DURATION = 4812; -  BREAK_REQUEST_DURATION_EXCEEDS_GLOBAL_DURATION = 4813; -  BREAK_FREQUENCY_MISSING_MAX_INTER_BREAK_DURATION = 4814; -  BREAK_FREQUENCY_MISSING_MIN_BREAK_DURATION = 4815;  -  SHIPMENT_TYPE_INCOMPATIBILITY_ERROR = 50;  -  SHIPMENT_TYPE_INCOMPATIBILITY_EMPTY_TYPE = 5001; -  SHIPMENT_TYPE_INCOMPATIBILITY_LESS_THAN_TWO_TYPES = 5002; -  SHIPMENT_TYPE_INCOMPATIBILITY_DUPLICATE_TYPE = 5003; -  SHIPMENT_TYPE_INCOMPATIBILITY_INVALID_INCOMPATIBILITY_MODE = 5004; -  SHIPMENT_TYPE_INCOMPATIBILITY_TOO_MANY_INCOMPATIBILITIES = 5005;  -  SHIPMENT_TYPE_REQUIREMENT_ERROR = 52;  -  SHIPMENT_TYPE_REQUIREMENT_NO_REQUIRED_TYPE = 52001; -  SHIPMENT_TYPE_REQUIREMENT_NO_DEPENDENT_TYPE = 52002; -  SHIPMENT_TYPE_REQUIREMENT_INVALID_REQUIREMENT_MODE = 52003; -  SHIPMENT_TYPE_REQUIREMENT_TOO_MANY_REQUIREMENTS = 52004; -  SHIPMENT_TYPE_REQUIREMENT_EMPTY_REQUIRED_TYPE = 52005; -  SHIPMENT_TYPE_REQUIREMENT_DUPLICATE_REQUIRED_TYPE = 52006; -  SHIPMENT_TYPE_REQUIREMENT_NO_REQUIRED_TYPE_FOUND = 52007; -  SHIPMENT_TYPE_REQUIREMENT_EMPTY_DEPENDENT_TYPE = 52008; -  SHIPMENT_TYPE_REQUIREMENT_DUPLICATE_DEPENDENT_TYPE = 52009; -  SHIPMENT_TYPE_REQUIREMENT_SELF_DEPENDENT_TYPE = 52010; -  SHIPMENT_TYPE_REQUIREMENT_GRAPH_HAS_CYCLES = 52011;  -  VEHICLE_OPERATOR_ERROR = 54;  -  VEHICLE_OPERATOR_EMPTY_TYPE = 5400; -  VEHICLE_OPERATOR_MULTIPLE_START_TIME_WINDOWS = 5401; -  VEHICLE_OPERATOR_SOFT_START_TIME_WINDOW = 5402; -  VEHICLE_OPERATOR_MULTIPLE_END_TIME_WINDOWS = 5403; -  VEHICLE_OPERATOR_SOFT_END_TIME_WINDOW = 5404;  -  DURATION_SECONDS_MATRIX_ERROR = 56;  -  DURATION_SECONDS_MATRIX_DURATION_NEGATIVE_OR_NAN = 5600; -  DURATION_SECONDS_MATRIX_DURATION_EXCEEDS_GLOBAL_DURATION = 5601;"
        },
        "display_name": {
          "type": "str",
          "description": "The error display name."
        },
        "fields": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.OptimizeToursValidationError.FieldReference]",
          "description": "An error context may involve 0, 1 (most of the time) or more fields. For example, referring to vehicle #4 and shipment #2's first pickup can be done as follows:  ::  fields { name: \"vehicles\" index: 4} fields { name: \"shipments\" index: 2 sub_field {name: \"pickups\" index: 0} }  Note, however, that the cardinality of ``fields`` should not change for a given error code."
        },
        "error_message": {
          "type": "str",
          "description": "Human-readable string describing the error. There is a 1:1 mapping between ``code`` and ``error_message`` (when code != \"UNSPECIFIED\").  *STABILITY*: Not stable: the error message associated to a given ``code`` may change (hopefully to clarify it) over time. Please rely on the ``display_name`` and ``code`` instead."
        },
        "offending_values": {
          "type": "str",
          "description": "May contain the value(s) of the field(s). This is not always available. You should absolutely not rely on it and use it only for manual model debugging."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Metrics",
      "docstring": "Overall metrics, aggregated over all routes.\n\nAttributes:\n    aggregated_route_metrics (google.cloud.optimization_v1.types.AggregatedMetrics):\n        Aggregated over the routes. Each metric is the sum (or max,\n        for loads) over all\n        [ShipmentRoute.metrics][google.cloud.optimization.v1.ShipmentRoute.metrics]\n        fields of the same name.\n    skipped_mandatory_shipment_count (int):\n        Number of mandatory shipments skipped.\n    used_vehicle_count (int):\n        Number of vehicles used. Note: if a vehicle route is empty\n        and\n        [Vehicle.used_if_route_is_empty][google.cloud.optimization.v1.Vehicle.used_if_route_is_empty]\n        is true, the vehicle is considered used.\n    earliest_vehicle_start_time (google.protobuf.timestamp_pb2.Timestamp):\n        The earliest start time for a used vehicle, computed as the\n        minimum over all used vehicles of\n        [ShipmentRoute.vehicle_start_time][google.cloud.optimization.v1.ShipmentRoute.vehicle_start_time].\n    latest_vehicle_end_ti",
      "attributes": {
        "aggregated_route_metrics": {
          "type": "google.cloud.optimization_v1.types.AggregatedMetrics",
          "description": "Aggregated over the routes. Each metric is the sum (or max, for loads) over all [ShipmentRoute.metrics][google.cloud.optimization.v1.ShipmentRoute.metrics] fields of the same name."
        },
        "skipped_mandatory_shipment_count": {
          "type": "int",
          "description": "Number of mandatory shipments skipped."
        },
        "used_vehicle_count": {
          "type": "int",
          "description": "Number of vehicles used. Note: if a vehicle route is empty and [Vehicle.used_if_route_is_empty][google.cloud.optimization.v1.Vehicle.used_if_route_is_empty] is true, the vehicle is considered used."
        },
        "earliest_vehicle_start_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "The earliest start time for a used vehicle, computed as the minimum over all used vehicles of [ShipmentRoute.vehicle_start_time][google.cloud.optimization.v1.ShipmentRoute.vehicle_start_time]."
        },
        "latest_vehicle_end_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "The latest end time for a used vehicle, computed as the maximum over all used vehicles of [ShipmentRoute.vehicle_end_time][google.cloud.optimization.v1.ShipmentRoute.vehicle_end_time]."
        },
        "costs": {
          "type": "MutableMapping[str, float]",
          "description": "Cost of the solution, broken down by cost-related request fields. The keys are proto paths, relative to the input OptimizeToursRequest, e.g. \"model.shipments.pickups.cost\", and the values are the total cost generated by the corresponding cost field, aggregated over the whole solution. In other words, costs[\"model.shipments.pickups.cost\"] is the sum of all pickup costs over the solution. All costs defined in the model are reported in detail here with the exception of costs related to TransitionAttributes that are only reported in an aggregated way as of 2022/01."
        },
        "total_cost": {
          "type": "float",
          "description": "Total cost of the solution. The sum of all values in the costs map."
        }
      }
    },
    {
      "type": "request_class",
      "name": "AsyncModelConfig",
      "docstring": "Information for solving one optimization model\nasynchronously.\n\nAttributes:\n    display_name (str):\n        User defined model name, can be used as alias\n        by users to keep track of models.\n    input_config (google.cloud.optimization_v1.types.InputConfig):\n        Required. Information about the input model.\n    output_config (google.cloud.optimization_v1.types.OutputConfig):\n        Required. The desired output location\n        information.\n    enable_checkpoints (bool):\n        If this is set, the model will be solved in the checkpoint\n        mode. In this mode, the input model can have a deadline\n        longer than 30 mins without the risk of interruption. The\n        model will be solved in multiple short-running stages. Each\n        stage generates an intermediate checkpoint and stores it in\n        the user's Cloud Storage buckets. The checkpoint mode should\n        be preferred over\n        allow_large_deadline_despite_interruption_risk since it\n        prevents the risk of interruption.",
      "attributes": {
        "display_name": {
          "type": "str",
          "description": "User defined model name, can be used as alias by users to keep track of models."
        },
        "input_config": {
          "type": "google.cloud.optimization_v1.types.InputConfig",
          "description": "Required. Information about the input model."
        },
        "output_config": {
          "type": "google.cloud.optimization_v1.types.OutputConfig",
          "description": "Required. The desired output location information."
        },
        "enable_checkpoints": {
          "type": "bool",
          "description": "If this is set, the model will be solved in the checkpoint mode. In this mode, the input model can have a deadline longer than 30 mins without the risk of interruption. The model will be solved in multiple short-running stages. Each stage generates an intermediate checkpoint and stores it in the user's Cloud Storage buckets. The checkpoint mode should be preferred over allow_large_deadline_despite_interruption_risk since it prevents the risk of interruption."
        }
      }
    },
    {
      "type": "request_class",
      "name": "DurationDistanceMatrix",
      "docstring": "Specifies a duration and distance matrix from visit and\nvehicle start locations to visit and vehicle end locations.\n\nAttributes:\n    rows (MutableSequence[google.cloud.optimization_v1.types.ShipmentModel.DurationDistanceMatrix.Row]):\n        Specifies the rows of the duration and distance matrix. It\n        must have as many elements as\n        [ShipmentModel.duration_distance_matrix_src_tags][google.cloud.optimization.v1.ShipmentModel.duration_distance_matrix_src_tags].\n    vehicle_start_tag (str):\n        Tag defining to which vehicles this duration and distance\n        matrix applies. If empty, this applies to all vehicles, and\n        there can only be a single matrix.\n\n        Each vehicle start must match exactly one matrix, i.e.\n        exactly one of their ``start_tags`` field must match the\n        ``vehicle_start_tag`` of a matrix (and of that matrix only).\n\n        All matrices must have a different ``vehicle_start_tag``.",
      "attributes": {
        "rows": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentModel.DurationDistanceMatrix.Row]",
          "description": "Specifies the rows of the duration and distance matrix. It must have as many elements as [ShipmentModel.duration_distance_matrix_src_tags][google.cloud.optimization.v1.ShipmentModel.duration_distance_matrix_src_tags]."
        },
        "vehicle_start_tag": {
          "type": "str",
          "description": "Tag defining to which vehicles this duration and distance matrix applies. If empty, this applies to all vehicles, and there can only be a single matrix.  Each vehicle start must match exactly one matrix, i.e. exactly one of their ``start_tags`` field must match the ``vehicle_start_tag`` of a matrix (and of that matrix only).  All matrices must have a different ``vehicle_start_tag``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "PrecedenceRule",
      "docstring": "A precedence rule between two events (each event is the pickup or\nthe delivery of a shipment): the \"second\" event has to start at\nleast ``offset_duration`` after \"first\" has started.\n\nSeveral precedences can refer to the same (or related) events, e.g.,\n\"pickup of B happens after delivery of A\" and \"pickup of C happens\nafter pickup of B\".\n\nFurthermore, precedences only apply when both shipments are\nperformed and are otherwise ignored.\n\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    first_index (int):\n        Shipment index of the \"first\" event. This\n        field must be specified.\n\n        This field is a member of `oneof`_ ``_first_index``.\n    first_is_delivery (bool):\n        Indicates if the \"first\" event is a delivery.\n    second_index (int):\n        Shipment index of the \"second\" event. This\n        field must be specified.\n\n        This field is a member of `oneof`_ ``_second_index``.\n    second_is_delivery (bool):\n        In",
      "attributes": {
        "first_index": {
          "type": "int",
          "description": "Shipment index of the \"first\" event. This field must be specified.  This field is a member of `oneof`_ ``_first_index``."
        },
        "first_is_delivery": {
          "type": "bool",
          "description": "Indicates if the \"first\" event is a delivery."
        },
        "second_index": {
          "type": "int",
          "description": "Shipment index of the \"second\" event. This field must be specified.  This field is a member of `oneof`_ ``_second_index``."
        },
        "second_is_delivery": {
          "type": "bool",
          "description": "Indicates if the \"second\" event is a delivery."
        },
        "offset_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "The offset between the \"first\" and \"second\" event. It can be negative."
        }
      }
    },
    {
      "type": "request_class",
      "name": "BreakRule",
      "docstring": "Deprecated: Use top level\n[BreakRule][google.cloud.optimization.v1.ShipmentModel.BreakRule]\ninstead. Rules to generate time breaks for a vehicle (e.g. lunch\nbreaks). A break is a contiguous period of time during which the\nvehicle remains idle at its current position and cannot perform any\nvisit. A break may occur:\n\n-  during the travel between two visits (which includes the time\n   right before or right after a visit, but not in the middle of a\n   visit), in which case it extends the corresponding transit time\n   between the visits\n-  before the vehicle start (the vehicle may not start in the middle\n   of a break), in which case it does not affect the vehicle start\n   time.\n-  after the vehicle end (ditto, with the vehicle end time).\n\nAttributes:\n    break_requests (MutableSequence[google.cloud.optimization_v1.types.ShipmentModel.BreakRule.BreakRequest]):\n        Sequence of breaks. See the ``BreakRequest`` message.\n    frequency_constraints (MutableSequence[google.cloud.optimization_v1.types.ShipmentModel.Br",
      "attributes": {
        "break_requests": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentModel.BreakRule.BreakRequest]",
          "description": "Sequence of breaks. See the ``BreakRequest`` message."
        },
        "frequency_constraints": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.ShipmentModel.BreakRule.FrequencyConstraint]",
          "description": "Several ``FrequencyConstraint`` may apply. They must all be satisfied by the ``BreakRequest``\\ s of this ``BreakRule``. See ``FrequencyConstraint``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "VisitRequest",
      "docstring": "Request for a visit which can be done by a vehicle: it has a\ngeo-location (or two, see below), opening and closing times\nrepresented by time windows, and a service duration time (time\nspent by the vehicle once it has arrived to pickup or drop off\ngoods).\n\nAttributes:\n    arrival_location (google.type.latlng_pb2.LatLng):\n        The geo-location where the vehicle arrives when performing\n        this ``VisitRequest``. If the shipment model has duration\n        distance matrices, ``arrival_location`` must not be\n        specified.\n    arrival_waypoint (google.cloud.optimization_v1.types.Waypoint):\n        The waypoint where the vehicle arrives when performing this\n        ``VisitRequest``. If the shipment model has duration\n        distance matrices, ``arrival_waypoint`` must not be\n        specified.\n    departure_location (google.type.latlng_pb2.LatLng):\n        The geo-location where the vehicle departs after completing\n        this ``VisitRequest``. Can be omitted if it is the same as\n        ``arrival_locat",
      "attributes": {
        "arrival_location": {
          "type": "google.type.latlng_pb2.LatLng",
          "description": "The geo-location where the vehicle arrives when performing this ``VisitRequest``. If the shipment model has duration distance matrices, ``arrival_location`` must not be specified."
        },
        "arrival_waypoint": {
          "type": "google.cloud.optimization_v1.types.Waypoint",
          "description": "The waypoint where the vehicle arrives when performing this ``VisitRequest``. If the shipment model has duration distance matrices, ``arrival_waypoint`` must not be specified."
        },
        "departure_location": {
          "type": "google.type.latlng_pb2.LatLng",
          "description": "The geo-location where the vehicle departs after completing this ``VisitRequest``. Can be omitted if it is the same as ``arrival_location``. If the shipment model has duration distance matrices, ``departure_location`` must not be specified."
        },
        "departure_waypoint": {
          "type": "google.cloud.optimization_v1.types.Waypoint",
          "description": "The waypoint where the vehicle departs after completing this ``VisitRequest``. Can be omitted if it is the same as ``arrival_waypoint``. If the shipment model has duration distance matrices, ``departure_waypoint`` must not be specified."
        },
        "tags": {
          "type": "MutableSequence[str]",
          "description": "Specifies tags attached to the visit request. Empty or duplicate strings are not allowed."
        },
        "time_windows": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.TimeWindow]",
          "description": "Time windows which constrain the arrival time at a visit. Note that a vehicle may depart outside of the arrival time window, i.e. arrival time + duration do not need to be inside a time window. This can result in waiting time if the vehicle arrives before [TimeWindow.start_time][google.cloud.optimization.v1.TimeWindow.start_time].  The absence of ``TimeWindow`` means that the vehicle can perform this visit at any time.  Time windows must be disjoint, i.e. no time window must overlap with or be adjacent to another, and they must be in increasing order.  ``cost_per_hour_after_soft_end_time`` and ``soft_end_time`` can only be set if there is a single time window."
        },
        "duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Duration of the visit, i.e. time spent by the vehicle between arrival and departure (to be added to the possible waiting time; see ``time_windows``)."
        },
        "cost": {
          "type": "float",
          "description": "Cost to service this visit request on a vehicle route. This can be used to pay different costs for each alternative pickup or delivery of a shipment. This cost must be in the same unit as ``Shipment.penalty_cost`` and must not be negative."
        },
        "load_demands": {
          "type": "MutableMapping[str, google.cloud.optimization_v1.types.Shipment.Load]",
          "description": "Load demands of this visit request. This is just like [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands] field, except that it only applies to this [VisitRequest][google.cloud.optimization.v1.Shipment.VisitRequest] instead of the whole [Shipment][google.cloud.optimization.v1.Shipment]. The demands listed here are added to the demands listed in [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands]."
        },
        "visit_types": {
          "type": "MutableSequence[str]",
          "description": "Specifies the types of the visit. This may be used to allocate additional time required for a vehicle to complete this visit (see [Vehicle.extra_visit_duration_for_visit_type][google.cloud.optimization.v1.Vehicle.extra_visit_duration_for_visit_type]).  A type can only appear once."
        },
        "label": {
          "type": "str",
          "description": "Specifies a label for this ``VisitRequest``. This label is reported in the response as ``visit_label`` in the corresponding [ShipmentRoute.Visit][google.cloud.optimization.v1.ShipmentRoute.Visit]."
        },
        "demands": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.CapacityQuantity]",
          "description": "Deprecated: Use [VisitRequest.load_demands][google.cloud.optimization.v1.Shipment.VisitRequest.load_demands] instead."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Load",
      "docstring": "When performing a visit, a predefined amount may be added to the\nvehicle load if it's a pickup, or subtracted if it's a delivery.\nThis message defines such amount. See\n[load_demands][google.cloud.optimization.v1.Shipment.load_demands].\n\nAttributes:\n    amount (int):\n        The amount by which the load of the vehicle\n        performing the corresponding visit will vary.\n        Since it is an integer, users are advised to\n        choose an appropriate unit to avoid loss of\n        precision. Must be \u2265 0.",
      "attributes": {
        "amount": {
          "type": "int",
          "description": "The amount by which the load of the vehicle performing the corresponding visit will vary. Since it is an integer, users are advised to choose an appropriate unit to avoid loss of precision. Must be \u2265 0."
        }
      }
    },
    {
      "type": "request_class",
      "name": "LoadLimit",
      "docstring": "Defines a load limit applying to a vehicle, e.g. \"this truck may\nonly carry up to 3500 kg\". See\n[load_limits][google.cloud.optimization.v1.Vehicle.load_limits].\n\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    max_load (int):\n        The maximum acceptable amount of load.\n\n        This field is a member of `oneof`_ ``_max_load``.\n    soft_max_load (int):\n        A soft limit of the load. See\n        [cost_per_unit_above_soft_max][google.cloud.optimization.v1.Vehicle.LoadLimit.cost_per_unit_above_soft_max].\n    cost_per_unit_above_soft_max (float):\n        If the load ever exceeds\n        [soft_max_load][google.cloud.optimization.v1.Vehicle.LoadLimit.soft_max_load]\n        along this vehicle's route, the following cost penalty\n        applies (only once per vehicle): (load -\n        [soft_max_load][google.cloud.optimization.v1.Vehicle.LoadLimit.soft_max_load])\n\n        -  [cost_per_unit_above_soft_max][google.cloud.optimization.v1.Veh",
      "attributes": {
        "max_load": {
          "type": "int",
          "description": "The maximum acceptable amount of load.  This field is a member of `oneof`_ ``_max_load``."
        },
        "soft_max_load": {
          "type": "int",
          "description": "A soft limit of the load. See [cost_per_unit_above_soft_max][google.cloud.optimization.v1.Vehicle.LoadLimit.cost_per_unit_above_soft_max]."
        },
        "cost_per_unit_above_soft_max": {
          "type": "float",
          "description": "If the load ever exceeds [soft_max_load][google.cloud.optimization.v1.Vehicle.LoadLimit.soft_max_load] along this vehicle's route, the following cost penalty"
        },
        "applies": {
          "type": "only once per vehicle",
          "description": "(load - [soft_max_load][google.cloud.optimization.v1.Vehicle.LoadLimit.soft_max_load])  -  [cost_per_unit_above_soft_max][google.cloud.optimization.v1.Vehicle.LoadLimit.cost_per_unit_above_soft_max]. All costs add up and must be in the same unit as [Shipment.penalty_cost][google.cloud.optimization.v1.Shipment.penalty_cost]."
        },
        "start_load_interval": {
          "type": "google.cloud.optimization_v1.types.Vehicle.LoadLimit.Interval",
          "description": "The acceptable load interval of the vehicle at the start of the route."
        },
        "end_load_interval": {
          "type": "google.cloud.optimization_v1.types.Vehicle.LoadLimit.Interval",
          "description": "The acceptable load interval of the vehicle at the end of the route."
        }
      }
    },
    {
      "type": "request_class",
      "name": "DurationLimit",
      "docstring": "A limit defining a maximum duration of the route of a\nvehicle. It can be either hard or soft.\n\nWhen a soft limit field is defined, both the soft max threshold\nand its associated cost must be defined together.\n\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    max_duration (google.protobuf.duration_pb2.Duration):\n        A hard limit constraining the duration to be at most\n        max_duration.\n    soft_max_duration (google.protobuf.duration_pb2.Duration):\n        A soft limit not enforcing a maximum duration limit, but\n        when violated makes the route incur a cost. This cost adds\n        up to other costs defined in the model, with the same unit.\n\n        If defined, ``soft_max_duration`` must be nonnegative. If\n        max_duration is also defined, ``soft_max_duration`` must be\n        less than max_duration.\n    cost_per_hour_after_soft_max (float):\n        Cost per hour incurred if the ``soft_max_duration``\n        threshold is",
      "attributes": {
        "max_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "A hard limit constraining the duration to be at most max_duration."
        },
        "soft_max_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "A soft limit not enforcing a maximum duration limit, but when violated makes the route incur a cost. This cost adds up to other costs defined in the model, with the same unit.  If defined, ``soft_max_duration`` must be nonnegative. If max_duration is also defined, ``soft_max_duration`` must be less than max_duration."
        },
        "cost_per_hour_after_soft_max": {
          "type": "float",
          "description": "Cost per hour incurred if the ``soft_max_duration`` threshold is violated. The additional cost is 0 if the duration is under the threshold, otherwise the cost depends on the duration as follows:  ::  cost_per_hour_after_soft_max * (duration - soft_max_duration)  The cost must be nonnegative.  This field is a member of `oneof`_ ``_cost_per_hour_after_soft_max``."
        },
        "quadratic_soft_max_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "A soft limit not enforcing a maximum duration limit, but when violated makes the route incur a cost, quadratic in the duration. This cost adds up to other costs defined in the model, with the same unit.  If defined, ``quadratic_soft_max_duration`` must be nonnegative. If ``max_duration`` is also defined, ``quadratic_soft_max_duration`` must be less than ``max_duration``, and the difference must be no larger than one day:  ::  `max_duration - quadratic_soft_max_duration <= 86400 seconds`"
        },
        "cost_per_square_hour_after_quadratic_soft_max": {
          "type": "float",
          "description": "Cost per square hour incurred if the ``quadratic_soft_max_duration`` threshold is violated.  The additional cost is 0 if the duration is under the threshold, otherwise the cost depends on the duration as follows:  ::  cost_per_square_hour_after_quadratic_soft_max * (duration - quadratic_soft_max_duration)^2  The cost must be nonnegative.  This field is a member of `oneof`_ ``_cost_per_square_hour_after_quadratic_soft_max``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "BreakRequest",
      "docstring": "The sequence of breaks (i.e. their number and order) that apply to\neach vehicle must be known beforehand. The repeated\n``BreakRequest``\\ s define that sequence, in the order in which they\nmust occur. Their time windows (``earliest_start_time`` /\n``latest_start_time``) may overlap, but they must be compatible with\nthe order (this is checked).\n\nAttributes:\n    earliest_start_time (google.protobuf.timestamp_pb2.Timestamp):\n        Required. Lower bound (inclusive) on the\n        start of the break.\n    latest_start_time (google.protobuf.timestamp_pb2.Timestamp):\n        Required. Upper bound (inclusive) on the\n        start of the break.\n    min_duration (google.protobuf.duration_pb2.Duration):\n        Required. Minimum duration of the break. Must\n        be positive.",
      "attributes": {
        "earliest_start_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Required. Lower bound (inclusive) on the start of the break."
        },
        "latest_start_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Required. Upper bound (inclusive) on the start of the break."
        },
        "min_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Required. Minimum duration of the break. Must be positive."
        }
      }
    },
    {
      "type": "request_class",
      "name": "FrequencyConstraint",
      "docstring": "One may further constrain the frequency and duration of the breaks\nspecified above, by enforcing a minimum break frequency, such as\n\"There must be a break of at least 1 hour every 12 hours\". Assuming\nthat this can be interpreted as \"Within any sliding time window of\n12h, there must be at least one break of at least one hour\", that\nexample would translate to the following ``FrequencyConstraint``:\n\n::\n\n   {\n      min_break_duration { seconds: 3600 }         # 1 hour.\n      max_inter_break_duration { seconds: 39600 }  # 11 hours (12 - 1 = 11).\n   }\n\nThe timing and duration of the breaks in the solution will respect\nall such constraints, in addition to the time windows and minimum\ndurations already specified in the ``BreakRequest``.\n\nA ``FrequencyConstraint`` may in practice apply to non-consecutive\nbreaks. For example, the following schedule honors the \"1h every\n12h\" example:\n\n::\n\n     04:00 vehicle start\n      .. performing travel and visits ..\n     09:00 1 hour break\n     10:00 end of the break\n      .. perfor",
      "attributes": {
        "min_break_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Required. Minimum break duration for this constraint. Nonnegative. See description of ``FrequencyConstraint``."
        },
        "max_inter_break_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Required. Maximum allowed span of any interval of time in the route that does not include at least partially a break of ``duration >= min_break_duration``. Must be positive."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Delay",
      "docstring": "Deprecated: Use\n[ShipmentRoute.Transition.delay_duration][google.cloud.optimization.v1.ShipmentRoute.Transition.delay_duration]\ninstead. Time interval spent on the route resulting from a\n[TransitionAttributes.delay][google.cloud.optimization.v1.TransitionAttributes.delay].\n\nAttributes:\n    start_time (google.protobuf.timestamp_pb2.Timestamp):\n        Start of the delay.\n    duration (google.protobuf.duration_pb2.Duration):\n        Duration of the delay.",
      "attributes": {
        "start_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Start of the delay."
        },
        "duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Duration of the delay."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Visit",
      "docstring": "A visit performed during a route. This visit corresponds to a pickup\nor a delivery of a ``Shipment``.\n\nAttributes:\n    shipment_index (int):\n        Index of the ``shipments`` field in the source\n        [ShipmentModel][google.cloud.optimization.v1.ShipmentModel].\n    is_pickup (bool):\n        If true the visit corresponds to a pickup of a ``Shipment``.\n        Otherwise, it corresponds to a delivery.\n    visit_request_index (int):\n        Index of ``VisitRequest`` in either the pickup or delivery\n        field of the ``Shipment`` (see ``is_pickup``).\n    start_time (google.protobuf.timestamp_pb2.Timestamp):\n        Time at which the visit starts. Note that the vehicle may\n        arrive earlier than this at the visit location. Times are\n        consistent with the ``ShipmentModel``.\n    load_demands (MutableMapping[str, google.cloud.optimization_v1.types.Shipment.Load]):\n        Total visit load demand as the sum of the shipment and the\n        visit request ``load_demands``. The values are negative if\n     ",
      "attributes": {
        "shipment_index": {
          "type": "int",
          "description": "Index of the ``shipments`` field in the source [ShipmentModel][google.cloud.optimization.v1.ShipmentModel]."
        },
        "is_pickup": {
          "type": "bool",
          "description": "If true the visit corresponds to a pickup of a ``Shipment``. Otherwise, it corresponds to a delivery."
        },
        "visit_request_index": {
          "type": "int",
          "description": "Index of ``VisitRequest`` in either the pickup or delivery field of the ``Shipment`` (see ``is_pickup``)."
        },
        "start_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Time at which the visit starts. Note that the vehicle may arrive earlier than this at the visit location. Times are consistent with the ``ShipmentModel``."
        },
        "load_demands": {
          "type": "MutableMapping[str, google.cloud.optimization_v1.types.Shipment.Load]",
          "description": "Total visit load demand as the sum of the shipment and the visit request ``load_demands``. The values are negative if the visit is a delivery. Demands are reported for the same types as the [Transition.loads][google.cloud.optimization.v1.ShipmentRoute.Transition] (see this field)."
        },
        "detour": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Extra detour time due to the shipments visited on the route before the visit and to the potential waiting time induced by time windows. If the visit is a delivery, the detour is computed from the corresponding pickup visit and is equal to:  ::  start_time(delivery) - start_time(pickup) - (duration(pickup) + travel duration from the pickup location to the delivery location).  Otherwise, it is computed from the vehicle ``start_location`` and is equal to:  ::  start_time - vehicle_start_time - travel duration from the vehicle's `start_location` to the visit."
        },
        "shipment_label": {
          "type": "str",
          "description": "Copy of the corresponding ``Shipment.label``, if specified in the ``Shipment``."
        },
        "visit_label": {
          "type": "str",
          "description": "Copy of the corresponding [VisitRequest.label][google.cloud.optimization.v1.Shipment.VisitRequest.label], if specified in the ``VisitRequest``."
        },
        "arrival_loads": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.CapacityQuantity]",
          "description": "Deprecated: Use [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads] instead. Vehicle loads upon arrival at the visit location, for each type specified in [Vehicle.capacities][google.cloud.optimization.v1.Vehicle.capacities], ``start_load_intervals``, ``end_load_intervals`` or ``demands``.  Exception: we omit loads for quantity types unconstrained by intervals and that don't have any non-zero demand on the route."
        },
        "delay_before_start": {
          "type": "google.cloud.optimization_v1.types.ShipmentRoute.Delay",
          "description": "Deprecated: Use [ShipmentRoute.Transition.delay_duration][google.cloud.optimization.v1.ShipmentRoute.Transition.delay_duration] instead. Delay occurring before the visit starts."
        },
        "demands": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.CapacityQuantity]",
          "description": "Deprecated: Use [Visit.load_demands][google.cloud.optimization.v1.ShipmentRoute.Visit.load_demands] instead."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Transition",
      "docstring": "Transition between two events on the route. See the description of\n[ShipmentRoute][google.cloud.optimization.v1.ShipmentRoute].\n\nIf the vehicle does not have a ``start_location`` and/or\n``end_location``, the corresponding travel metrics are 0.\n\nAttributes:\n    travel_duration (google.protobuf.duration_pb2.Duration):\n        Travel duration during this transition.\n    travel_distance_meters (float):\n        Distance traveled during the transition.\n    traffic_info_unavailable (bool):\n        When traffic is requested via\n        [OptimizeToursRequest.consider_road_traffic]\n        [google.cloud.optimization.v1.OptimizeToursRequest.consider_road_traffic],\n        and the traffic info couldn't be retrieved for a\n        ``Transition``, this boolean is set to true. This may be\n        temporary (rare hiccup in the realtime traffic servers) or\n        permanent (no data for this location).\n    delay_duration (google.protobuf.duration_pb2.Duration):\n        Sum of the delay durations applied to this transition. If\n",
      "attributes": {
        "travel_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Travel duration during this transition."
        },
        "travel_distance_meters": {
          "type": "float",
          "description": "Distance traveled during the transition."
        },
        "traffic_info_unavailable": {
          "type": "bool",
          "description": "When traffic is requested via [OptimizeToursRequest.consider_road_traffic] [google.cloud.optimization.v1.OptimizeToursRequest.consider_road_traffic], and the traffic info couldn't be retrieved for a ``Transition``, this boolean is set to true. This may be temporary (rare hiccup in the realtime traffic servers) or permanent (no data for this location)."
        },
        "delay_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Sum of the delay durations applied to this transition. If any, the delay starts exactly ``delay_duration`` seconds before the next event (visit or vehicle end). See [TransitionAttributes.delay][google.cloud.optimization.v1.TransitionAttributes.delay]."
        },
        "break_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Sum of the duration of the breaks occurring during this transition, if any. Details about each break's start time and duration are stored in [ShipmentRoute.breaks][google.cloud.optimization.v1.ShipmentRoute.breaks]."
        },
        "wait_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Time spent waiting during this transition. Wait duration corresponds to idle time and does not include break time. Also note that this wait time may be split into several non-contiguous intervals."
        },
        "total_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Total duration of the transition, provided for convenience. It is equal to:  -  next visit ``start_time`` (or ``vehicle_end_time`` if this is the last transition) - this transition's ``start_time``; -  if ``ShipmentRoute.has_traffic_infeasibilities`` is false, the following additionally holds: \\`total_duration = travel_duration + delay_duration  -  break_duration + wait_duration`."
        },
        "start_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Start time of this transition."
        },
        "route_polyline": {
          "type": "google.cloud.optimization_v1.types.ShipmentRoute.EncodedPolyline",
          "description": "The encoded polyline representation of the route followed during the transition. This field is only populated if [populate_transition_polylines] [google.cloud.optimization.v1.OptimizeToursRequest.populate_transition_polylines] is set to true."
        },
        "vehicle_loads": {
          "type": "MutableMapping[str, google.cloud.optimization_v1.types.ShipmentRoute.VehicleLoad]",
          "description": "Vehicle loads during this transition, for each type that either appears in this vehicle's [Vehicle.load_limits][google.cloud.optimization.v1.Vehicle.load_limits], or that have non-zero [Shipment.load_demands][google.cloud.optimization.v1.Shipment.load_demands] on some shipment performed on this route.  The loads during the first transition are the starting loads of the vehicle route. Then, after each visit, the visit's ``load_demands`` are either added or subtracted to get the next transition's loads, depending on whether the visit was a pickup or a delivery."
        },
        "loads": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.CapacityQuantity]",
          "description": "Deprecated: Use [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads] instead."
        }
      }
    },
    {
      "type": "request_class",
      "name": "VehicleLoad",
      "docstring": "Reports the actual load of the vehicle at some point along the\nroute, for a given type (see\n[Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads]).\n\nAttributes:\n    amount (int):\n        The amount of load on the vehicle, for the given type. The\n        unit of load is usually indicated by the type. See\n        [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads].",
      "attributes": {
        "amount": {
          "type": "int",
          "description": "The amount of load on the vehicle, for the given type. The unit of load is usually indicated by the type. See [Transition.vehicle_loads][google.cloud.optimization.v1.ShipmentRoute.Transition.vehicle_loads]."
        }
      }
    },
    {
      "type": "request_class",
      "name": "EncodedPolyline",
      "docstring": "The encoded representation of a polyline. More information on\npolyline encoding can be found here:\n\nhttps://developers.google.com/maps/documentation/utilities/polylinealgorithm\nhttps://developers.google.com/maps/documentation/javascript/reference/geometry#encoding.\n\nAttributes:\n    points (str):\n        String representing encoded points of the\n        polyline.",
      "attributes": {
        "points": {
          "type": "str",
          "description": "String representing encoded points of the polyline."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Break",
      "docstring": "Data representing the execution of a break.\n\nAttributes:\n    start_time (google.protobuf.timestamp_pb2.Timestamp):\n        Start time of a break.\n    duration (google.protobuf.duration_pb2.Duration):\n        Duration of a break.",
      "attributes": {
        "start_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Start time of a break."
        },
        "duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Duration of a break."
        }
      }
    },
    {
      "type": "request_class",
      "name": "TravelStep",
      "docstring": "Deprecated: Use\n[ShipmentRoute.Transition][google.cloud.optimization.v1.ShipmentRoute.Transition]\ninstead. Travel between each visit along the route: from the\nvehicle's ``start_location`` to the first visit's\n``arrival_location``, then from the first visit's\n``departure_location`` to the second visit's ``arrival_location``,\nand so on until the vehicle's ``end_location``. This accounts only\nfor the actual travel between visits, not counting the waiting time,\nthe time spent performing a visit, nor the distance covered during a\nvisit.\n\nInvariant: ``travel_steps_size() == visits_size() + 1``.\n\nIf the vehicle does not have a start\\_ and/or end_location, the\ncorresponding travel metrics are 0 and/or empty.\n\nAttributes:\n    duration (google.protobuf.duration_pb2.Duration):\n        Duration of the travel step.\n    distance_meters (float):\n        Distance traveled during the step.\n    traffic_info_unavailable (bool):\n        When traffic is requested via\n        [OptimizeToursRequest.consider_road_traffic][google.clo",
      "attributes": {
        "duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Duration of the travel step."
        },
        "distance_meters": {
          "type": "float",
          "description": "Distance traveled during the step."
        },
        "traffic_info_unavailable": {
          "type": "bool",
          "description": "When traffic is requested via [OptimizeToursRequest.consider_road_traffic][google.cloud.optimization.v1.OptimizeToursRequest.consider_road_traffic], and the traffic info couldn't be retrieved for a TravelStep, this boolean is set to true. This may be temporary (rare hiccup in the realtime traffic servers) or permanent (no data for this location)."
        },
        "route_polyline": {
          "type": "google.cloud.optimization_v1.types.ShipmentRoute.EncodedPolyline",
          "description": "The encoded polyline representation of the route followed during the step.  This field is only populated if [OptimizeToursRequest.populate_travel_step_polylines][google.cloud.optimization.v1.OptimizeToursRequest.populate_travel_step_polylines] is set to true."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Reason",
      "docstring": "If we can explain why the shipment was skipped, reasons will be\nlisted here. If the reason is not the same for all vehicles,\n``reason`` will have more than 1 element. A skipped shipment cannot\nhave duplicate reasons, i.e. where all fields are the same except\nfor ``example_vehicle_index``. Example:\n\n::\n\n   reasons {\n     code: DEMAND_EXCEEDS_VEHICLE_CAPACITY\n     example_vehicle_index: 1\n     example_exceeded_capacity_type: \"Apples\"\n   }\n   reasons {\n     code: DEMAND_EXCEEDS_VEHICLE_CAPACITY\n     example_vehicle_index: 3\n     example_exceeded_capacity_type: \"Pears\"\n   }\n   reasons {\n     code: CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DISTANCE_LIMIT\n     example_vehicle_index: 1\n   }\n\nThe skipped shipment is incompatible with all vehicles. The reasons\nmay be different for all vehicles but at least one vehicle's\n\"Apples\" capacity would be exceeded (including vehicle 1), at least\none vehicle's \"Pears\" capacity would be exceeded (including vehicle\n3) and at least one vehicle's distance limit would be exceeded\n(includin",
      "attributes": {
        "code": {
          "type": "google.cloud.optimization_v1.types.SkippedShipment.Reason.Code",
          "description": "Refer to the comments of Code."
        },
        "example_vehicle_index": {
          "type": "int",
          "description": "If the reason is related to a shipment-vehicle incompatibility, this field provides the index of one relevant vehicle.  This field is a member of `oneof`_ ``_example_vehicle_index``."
        },
        "example_exceeded_capacity_type": {
          "type": "str",
          "description": "If the reason code is ``DEMAND_EXCEEDS_VEHICLE_CAPACITY``, documents one capacity type that is exceeded."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ConstraintRelaxation",
      "docstring": "For a group of vehicles, specifies at what threshold(s) constraints\non visits will be relaxed and to which level. Shipments listed in\nthe ``skipped_shipment`` field are constrained to be skipped; i.e.,\nthey cannot be performed.\n\nAttributes:\n    relaxations (MutableSequence[google.cloud.optimization_v1.types.InjectedSolutionConstraint.ConstraintRelaxation.Relaxation]):\n        All the visit constraint relaxations that will apply to\n        visits on routes with vehicles in ``vehicle_indices``.\n    vehicle_indices (MutableSequence[int]):\n        Specifies the vehicle indices to which the visit constraint\n        ``relaxations`` apply. If empty, this is considered the\n        default and the ``relaxations`` apply to all vehicles that\n        are not specified in other ``constraint_relaxations``. There\n        can be at most one default, i.e., at most one constraint\n        relaxation field is allowed empty ``vehicle_indices``. A\n        vehicle index can only be listed once, even within several\n        ``constra",
      "attributes": {
        "relaxations": {
          "type": "MutableSequence[google.cloud.optimization_v1.types.InjectedSolutionConstraint.ConstraintRelaxation.Relaxation]",
          "description": "All the visit constraint relaxations that will apply to visits on routes with vehicles in ``vehicle_indices``."
        },
        "vehicle_indices": {
          "type": "MutableSequence[int]",
          "description": "Specifies the vehicle indices to which the visit constraint ``relaxations`` apply. If empty, this is considered the default and the ``relaxations`` apply to all vehicles that are not specified in other ``constraint_relaxations``. There can be at most one default, i.e., at most one constraint relaxation field is allowed empty ``vehicle_indices``. A vehicle index can only be listed once, even within several ``constraint_relaxations``.  A vehicle index is mapped the same as [ShipmentRoute.vehicle_index][google.cloud.optimization.v1.ShipmentRoute.vehicle_index], if ``interpret_injected_solutions_using_labels`` is true (see ``fields`` comment)."
        }
      }
    },
    {
      "type": "request_class",
      "name": "FieldReference",
      "docstring": "Specifies a context for the validation error. A ``FieldReference``\nalways refers to a given field in this file and follows the same\nhierarchical structure. For example, we may specify element #2 of\n``start_time_windows`` of vehicle #5 using:\n\n::\n\n   name: \"vehicles\" index: 5 sub_field { name: \"end_time_windows\" index: 2 }\n\nWe however omit top-level entities such as ``OptimizeToursRequest``\nor ``ShipmentModel`` to avoid crowding the message.\n\nThis message has `oneof`_ fields (mutually exclusive fields).\nFor each oneof, at most one member field can be set at the same time.\nSetting any member of the oneof automatically clears all other\nmembers.\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    name (str):\n        Name of the field, e.g., \"vehicles\".\n    index (int):\n        Index of the field if repeated.\n\n        This field is a member of `oneof`_ ``index_or_key``.\n    key (str):\n        Key if the field is a map.\n\n        This field is ",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Name of the field, e.g., \"vehicles\"."
        },
        "index": {
          "type": "int",
          "description": "Index of the field if repeated.  This field is a member of `oneof`_ ``index_or_key``."
        },
        "key": {
          "type": "str",
          "description": "Key if the field is a map.  This field is a member of `oneof`_ ``index_or_key``."
        },
        "sub_field": {
          "type": "google.cloud.optimization_v1.types.OptimizeToursValidationError.FieldReference",
          "description": "Recursively nested sub-field, if needed."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Row",
      "docstring": "Specifies a row of the duration and distance matrix.\n\nAttributes:\n    durations (MutableSequence[google.protobuf.duration_pb2.Duration]):\n        Duration values for a given row. It must have as many\n        elements as\n        [ShipmentModel.duration_distance_matrix_dst_tags][google.cloud.optimization.v1.ShipmentModel.duration_distance_matrix_dst_tags].\n    meters (MutableSequence[float]):\n        Distance values for a given row. If no costs or constraints\n        refer to distances in the model, this can be left empty;\n        otherwise it must have as many elements as ``durations``.",
      "attributes": {
        "durations": {
          "type": "MutableSequence[google.protobuf.duration_pb2.Duration]",
          "description": "Duration values for a given row. It must have as many elements as [ShipmentModel.duration_distance_matrix_dst_tags][google.cloud.optimization.v1.ShipmentModel.duration_distance_matrix_dst_tags]."
        },
        "meters": {
          "type": "MutableSequence[float]",
          "description": "Distance values for a given row. If no costs or constraints refer to distances in the model, this can be left empty; otherwise it must have as many elements as ``durations``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "BreakRequest",
      "docstring": "The sequence of breaks (i.e. their number and order) that apply to\neach vehicle must be known beforehand. The repeated\n``BreakRequest``\\ s define that sequence, in the order in which they\nmust occur. Their time windows (``earliest_start_time`` /\n``latest_start_time``) may overlap, but they must be compatible with\nthe order (this is checked).\n\nAttributes:\n    earliest_start_time (google.protobuf.timestamp_pb2.Timestamp):\n        Required. Lower bound (inclusive) on the\n        start of the break.\n    latest_start_time (google.protobuf.timestamp_pb2.Timestamp):\n        Required. Upper bound (inclusive) on the\n        start of the break.\n    min_duration (google.protobuf.duration_pb2.Duration):\n        Required. Minimum duration of the break. Must\n        be positive.",
      "attributes": {
        "earliest_start_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Required. Lower bound (inclusive) on the start of the break."
        },
        "latest_start_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Required. Upper bound (inclusive) on the start of the break."
        },
        "min_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Required. Minimum duration of the break. Must be positive."
        }
      }
    },
    {
      "type": "request_class",
      "name": "FrequencyConstraint",
      "docstring": "One may further constrain the frequency and duration of the breaks\nspecified above, by enforcing a minimum break frequency, such as\n\"There must be a break of at least 1 hour every 12 hours\". Assuming\nthat this can be interpreted as \"Within any sliding time window of\n12h, there must be at least one break of at least one hour\", that\nexample would translate to the following ``FrequencyConstraint``:\n\n::\n\n   {\n      min_break_duration { seconds: 3600 }         # 1 hour.\n      max_inter_break_duration { seconds: 39600 }  # 11 hours (12 - 1 = 11).\n   }\n\nThe timing and duration of the breaks in the solution will respect\nall such constraints, in addition to the time windows and minimum\ndurations already specified in the ``BreakRequest``.\n\nA ``FrequencyConstraint`` may in practice apply to non-consecutive\nbreaks. For example, the following schedule honors the \"1h every\n12h\" example:\n\n::\n\n     04:00 vehicle start\n      .. performing travel and visits ..\n     09:00 1 hour break\n     10:00 end of the break\n      .. perfor",
      "attributes": {
        "min_break_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Required. Minimum break duration for this constraint. Nonnegative. See description of ``FrequencyConstraint``."
        },
        "max_inter_break_duration": {
          "type": "google.protobuf.duration_pb2.Duration",
          "description": "Required. Maximum allowed span of any interval of time in the route that does not include at least partially a break of ``duration >= min_break_duration``. Must be positive."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Interval",
      "docstring": "Interval of acceptable load amounts.\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    min_ (int):\n        A minimum acceptable load. Must be \u2265 0. If they're both\n        specified,\n        [min][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.min]\n        must be \u2264\n        [max][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.max].\n    max_ (int):\n        A maximum acceptable load. Must be \u2265 0. If unspecified, the\n        maximum load is unrestricted by this message. If they're\n        both specified,\n        [min][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.min]\n        must be \u2264\n        [max][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.max].\n\n        This field is a member of `oneof`_ ``_max``.",
      "attributes": {
        "min_": {
          "type": "int",
          "description": "A minimum acceptable load. Must be \u2265 0. If they're both specified, [min][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.min] must be \u2264 [max][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.max]."
        },
        "max_": {
          "type": "int",
          "description": "A maximum acceptable load. Must be \u2265 0. If unspecified, the maximum load is unrestricted by this message. If they're both specified, [min][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.min] must be \u2264 [max][google.cloud.optimization.v1.Vehicle.LoadLimit.Interval.max].  This field is a member of `oneof`_ ``_max``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Relaxation",
      "docstring": "If ``relaxations`` is empty, the start time and sequence of all\nvisits on ``routes`` are fully constrained and no new visits may be\ninserted or added to those routes. Also, a vehicle's start and end\ntime in ``routes`` is fully constrained, unless the vehicle is empty\n(i.e., has no visits and has ``used_if_route_is_empty`` set to false\nin the model).\n\n``relaxations(i).level`` specifies the constraint relaxation level\napplied to a visit #j that satisfies:\n\n-  ``route.visits(j).start_time >= relaxations(i).threshold_time``\n   AND\n-  ``j + 1 >= relaxations(i).threshold_visit_count``\n\nSimilarly, the vehicle start is relaxed to ``relaxations(i).level``\nif it satisfies:\n\n-  ``vehicle_start_time >= relaxations(i).threshold_time`` AND\n-  ``relaxations(i).threshold_visit_count == 0`` and the vehicle end\n   is relaxed to ``relaxations(i).level`` if it satisfies:\n-  ``vehicle_end_time >= relaxations(i).threshold_time`` AND\n-  ``route.visits_size() + 1 >= relaxations(i).threshold_visit_count``\n\nTo apply a relaxation level",
      "attributes": {
        "level": {
          "type": "google.cloud.optimization_v1.types.InjectedSolutionConstraint.ConstraintRelaxation.Relaxation.Level",
          "description": "The constraint relaxation level that applies when the conditions at or after ``threshold_time`` AND at least ``threshold_visit_count`` are satisfied."
        },
        "threshold_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "The time at or after which the relaxation ``level`` may be applied."
        },
        "threshold_visit_count": {
          "type": "int",
          "description": "The number of visits at or after which the relaxation ``level`` may be applied. If ``threshold_visit_count`` is 0 (or unset), the ``level`` may be applied directly at the vehicle start.  If it is ``route.visits_size() + 1``, the ``level`` may only be applied to the vehicle end. If it is more than ``route.visits_size() + 1``, ``level`` is not applied at all for that route."
        }
      }
    }
  ]
}
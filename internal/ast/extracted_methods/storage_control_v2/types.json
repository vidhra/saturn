{
  "\\Users\\AMD\\vidhra\\internal\\ast\\google-cloud-python\\packages\\google-cloud-storage-control\\google\\cloud\\storage_control_v2\\types\\storage_control.py": [
    {
      "type": "request_class",
      "name": "PendingRenameInfo",
      "docstring": "Contains information about a pending rename operation.\n\nAttributes:\n    operation (str):\n        Output only. The name of the rename\n        operation.",
      "attributes": {
        "operation": {
          "type": "str",
          "description": "Output only. The name of the rename operation."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Folder",
      "docstring": "A folder resource. This resource can only exist in a\nhierarchical namespace enabled bucket.\n\nAttributes:\n    name (str):\n        Identifier. The name of this folder. Format:\n        ``projects/{project}/buckets/{bucket}/folders/{folder}``\n    metageneration (int):\n        Output only. The version of the metadata for\n        this folder. Used for preconditions and for\n        detecting changes in metadata.\n    create_time (google.protobuf.timestamp_pb2.Timestamp):\n        Output only. The creation time of the folder.\n    update_time (google.protobuf.timestamp_pb2.Timestamp):\n        Output only. The modification time of the\n        folder.\n    pending_rename_info (google.cloud.storage_control_v2.types.PendingRenameInfo):\n        Output only. Only present if the folder is\n        part of an ongoing RenameFolder operation.\n        Contains information which can be used to query\n        the operation status. The presence of this field\n        also indicates all write operations are blocked\n        for this folder",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Identifier. The name of this folder. Format: ``projects/{project}/buckets/{bucket}/folders/{folder}``"
        },
        "metageneration": {
          "type": "int",
          "description": "Output only. The version of the metadata for this folder. Used for preconditions and for detecting changes in metadata."
        },
        "create_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Output only. The creation time of the folder."
        },
        "update_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Output only. The modification time of the folder."
        },
        "pending_rename_info": {
          "type": "google.cloud.storage_control_v2.types.PendingRenameInfo",
          "description": "Output only. Only present if the folder is part of an ongoing RenameFolder operation. Contains information which can be used to query the operation status. The presence of this field also indicates all write operations are blocked for this folder, including folder, managed folder, and object operations."
        }
      }
    },
    {
      "type": "request_class",
      "name": "GetFolderRequest",
      "docstring": "Request message for GetFolder. This operation is only\napplicable to a hierarchical namespace enabled bucket.\n\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    name (str):\n        Required. Name of the folder. Format:\n        ``projects/{project}/buckets/{bucket}/folders/{folder}``\n    if_metageneration_match (int):\n        Makes the operation only succeed conditional\n        on whether the folder's current metageneration\n        matches the given value.\n\n        This field is a member of `oneof`_ ``_if_metageneration_match``.\n    if_metageneration_not_match (int):\n        Makes the operation only succeed conditional\n        on whether the folder's current metageneration\n        does not match the given value.\n\n        This field is a member of `oneof`_ ``_if_metageneration_not_match``.\n    request_id (str):\n        Optional. A unique identifier for this\n        request. UUID is the recommended format, but\n        other formats are sti",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Required. Name of the folder. Format: ``projects/{project}/buckets/{bucket}/folders/{folder}``"
        },
        "if_metageneration_match": {
          "type": "int",
          "description": "Makes the operation only succeed conditional on whether the folder's current metageneration matches the given value.  This field is a member of `oneof`_ ``_if_metageneration_match``."
        },
        "if_metageneration_not_match": {
          "type": "int",
          "description": "Makes the operation only succeed conditional on whether the folder's current metageneration does not match the given value.  This field is a member of `oneof`_ ``_if_metageneration_not_match``."
        },
        "request_id": {
          "type": "str",
          "description": "Optional. A unique identifier for this request. UUID is the recommended format, but other formats are still accepted."
        }
      }
    },
    {
      "type": "request_class",
      "name": "CreateFolderRequest",
      "docstring": "Request message for CreateFolder. This operation is only\napplicable to a hierarchical namespace enabled bucket.\n\nAttributes:\n    parent (str):\n        Required. Name of the bucket in which the\n        folder will reside. The bucket must be a\n        hierarchical namespace enabled bucket.\n    folder (google.cloud.storage_control_v2.types.Folder):\n        Required. Properties of the new folder being created. The\n        bucket and name of the folder are specified in the parent\n        and folder_id fields, respectively. Populating those fields\n        in ``folder`` will result in an error.\n    folder_id (str):\n        Required. The full name of a folder, including all its\n        parent folders. Folders use single '/' characters as a\n        delimiter. The folder_id must end with a slash. For example,\n        the folder_id of \"books/biographies/\" would create a new\n        \"biographies/\" folder under the \"books/\" folder.\n    recursive (bool):\n        Optional. If true, parent folder doesn't have\n        to be p",
      "attributes": {
        "parent": {
          "type": "str",
          "description": "Required. Name of the bucket in which the folder will reside. The bucket must be a hierarchical namespace enabled bucket."
        },
        "folder": {
          "type": "google.cloud.storage_control_v2.types.Folder",
          "description": "Required. Properties of the new folder being created. The bucket and name of the folder are specified in the parent and folder_id fields, respectively. Populating those fields in ``folder`` will result in an error."
        },
        "folder_id": {
          "type": "str",
          "description": "Required. The full name of a folder, including all its parent folders. Folders use single '/' characters as a delimiter. The folder_id must end with a slash. For example, the folder_id of \"books/biographies/\" would create a new \"biographies/\" folder under the \"books/\" folder."
        },
        "recursive": {
          "type": "bool",
          "description": "Optional. If true, parent folder doesn't have to be present and all missing ancestor folders will be created atomically."
        },
        "request_id": {
          "type": "str",
          "description": "Optional. A unique identifier for this request. UUID is the recommended format, but other formats are still accepted."
        }
      }
    },
    {
      "type": "request_class",
      "name": "DeleteFolderRequest",
      "docstring": "Request message for DeleteFolder. This operation is only\napplicable to a hierarchical namespace enabled bucket.\n\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    name (str):\n        Required. Name of the folder. Format:\n        ``projects/{project}/buckets/{bucket}/folders/{folder}``\n    if_metageneration_match (int):\n        Makes the operation only succeed conditional\n        on whether the folder's current metageneration\n        matches the given value.\n\n        This field is a member of `oneof`_ ``_if_metageneration_match``.\n    if_metageneration_not_match (int):\n        Makes the operation only succeed conditional\n        on whether the folder's current metageneration\n        does not match the given value.\n\n        This field is a member of `oneof`_ ``_if_metageneration_not_match``.\n    request_id (str):\n        Optional. A unique identifier for this\n        request. UUID is the recommended format, but\n        other formats are ",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Required. Name of the folder. Format: ``projects/{project}/buckets/{bucket}/folders/{folder}``"
        },
        "if_metageneration_match": {
          "type": "int",
          "description": "Makes the operation only succeed conditional on whether the folder's current metageneration matches the given value.  This field is a member of `oneof`_ ``_if_metageneration_match``."
        },
        "if_metageneration_not_match": {
          "type": "int",
          "description": "Makes the operation only succeed conditional on whether the folder's current metageneration does not match the given value.  This field is a member of `oneof`_ ``_if_metageneration_not_match``."
        },
        "request_id": {
          "type": "str",
          "description": "Optional. A unique identifier for this request. UUID is the recommended format, but other formats are still accepted."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ListFoldersRequest",
      "docstring": "Request message for ListFolders. This operation is only\napplicable to a hierarchical namespace enabled bucket.\n\nAttributes:\n    parent (str):\n        Required. Name of the bucket in which to look\n        for folders. The bucket must be a hierarchical\n        namespace enabled bucket.\n    page_size (int):\n        Optional. Maximum number of folders to return\n        in a single response. The service will use this\n        parameter or 1,000 items, whichever is smaller.\n    page_token (str):\n        Optional. A previously-returned page token\n        representing part of the larger set of results\n        to view.\n    prefix (str):\n        Optional. Filter results to folders whose\n        names begin with this prefix. If set, the value\n        must either be an empty string or end with a\n        '/'.\n    delimiter (str):\n        Optional. If set, returns results in a\n        directory-like mode. The results will only\n        include folders that either exactly match the\n        above prefix, or are one level below",
      "attributes": {
        "parent": {
          "type": "str",
          "description": "Required. Name of the bucket in which to look for folders. The bucket must be a hierarchical namespace enabled bucket."
        },
        "page_size": {
          "type": "int",
          "description": "Optional. Maximum number of folders to return in a single response. The service will use this parameter or 1,000 items, whichever is smaller."
        },
        "page_token": {
          "type": "str",
          "description": "Optional. A previously-returned page token representing part of the larger set of results to view."
        },
        "prefix": {
          "type": "str",
          "description": "Optional. Filter results to folders whose names begin with this prefix. If set, the value must either be an empty string or end with a '/'."
        },
        "delimiter": {
          "type": "str",
          "description": "Optional. If set, returns results in a directory-like mode. The results will only include folders that either exactly match the above prefix, or are one level below the prefix. The only supported value is '/'."
        },
        "lexicographic_start": {
          "type": "str",
          "description": "Optional. Filter results to folders whose names are lexicographically equal to or after lexicographic_start. If lexicographic_end is also set, the folders listed have names between lexicographic_start (inclusive) and lexicographic_end (exclusive)."
        },
        "lexicographic_end": {
          "type": "str",
          "description": "Optional. Filter results to folders whose names are lexicographically before lexicographic_end. If lexicographic_start is also set, the folders listed have names between lexicographic_start (inclusive) and lexicographic_end (exclusive)."
        },
        "request_id": {
          "type": "str",
          "description": "Optional. A unique identifier for this request. UUID is the recommended format, but other formats are still accepted."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ListFoldersResponse",
      "docstring": "Response message for ListFolders.\n\nAttributes:\n    folders (MutableSequence[google.cloud.storage_control_v2.types.Folder]):\n        The list of child folders\n    next_page_token (str):\n        The continuation token, used to page through\n        large result sets. Provide this value in a\n        subsequent request to return the next page of\n        results.",
      "attributes": {
        "folders": {
          "type": "MutableSequence[google.cloud.storage_control_v2.types.Folder]",
          "description": "The list of child folders"
        },
        "next_page_token": {
          "type": "str",
          "description": "The continuation token, used to page through large result sets. Provide this value in a subsequent request to return the next page of results."
        }
      }
    },
    {
      "type": "request_class",
      "name": "RenameFolderRequest",
      "docstring": "Request message for RenameFolder. This operation is only\napplicable to a hierarchical namespace enabled bucket.\n\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    name (str):\n        Required. Name of the source folder being renamed. Format:\n        ``projects/{project}/buckets/{bucket}/folders/{folder}``\n    destination_folder_id (str):\n        Required. The destination folder ID, e.g. ``foo/bar/``.\n    if_metageneration_match (int):\n        Makes the operation only succeed conditional\n        on whether the source folder's current\n        metageneration matches the given value.\n\n        This field is a member of `oneof`_ ``_if_metageneration_match``.\n    if_metageneration_not_match (int):\n        Makes the operation only succeed conditional\n        on whether the source folder's current\n        metageneration does not match the given value.\n\n        This field is a member of `oneof`_ ``_if_metageneration_not_match``.\n    request_id (",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Required. Name of the source folder being renamed. Format: ``projects/{project}/buckets/{bucket}/folders/{folder}``"
        },
        "destination_folder_id": {
          "type": "str",
          "description": "Required. The destination folder ID, e.g. ``foo/bar/``."
        },
        "if_metageneration_match": {
          "type": "int",
          "description": "Makes the operation only succeed conditional on whether the source folder's current metageneration matches the given value.  This field is a member of `oneof`_ ``_if_metageneration_match``."
        },
        "if_metageneration_not_match": {
          "type": "int",
          "description": "Makes the operation only succeed conditional on whether the source folder's current metageneration does not match the given value.  This field is a member of `oneof`_ ``_if_metageneration_not_match``."
        },
        "request_id": {
          "type": "str",
          "description": "Optional. A unique identifier for this request. UUID is the recommended format, but other formats are still accepted. This request is only idempotent if a ``request_id`` is provided."
        }
      }
    },
    {
      "type": "request_class",
      "name": "CommonLongRunningOperationMetadata",
      "docstring": "The message contains metadata that is common to all Storage Control\nlong-running operations, present in its\n``google.longrunning.Operation`` messages, and accessible via\n``metadata.common_metadata``.\n\nAttributes:\n    create_time (google.protobuf.timestamp_pb2.Timestamp):\n        Output only. The time the operation was\n        created.\n    end_time (google.protobuf.timestamp_pb2.Timestamp):\n        Output only. The time the operation finished\n        running.\n    update_time (google.protobuf.timestamp_pb2.Timestamp):\n        Output only. The time the operation was last\n        modified.\n    type_ (str):\n        Output only. The type of operation invoked.\n    requested_cancellation (bool):\n        Output only. Identifies whether the user has\n        requested cancellation.\n    progress_percent (int):\n        Output only. The estimated progress of the operation in\n        percentage [0, 100]. The value -1 means the progress is\n        unknown.",
      "attributes": {
        "create_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Output only. The time the operation was created."
        },
        "end_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Output only. The time the operation finished running."
        },
        "update_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Output only. The time the operation was last modified."
        },
        "type_": {
          "type": "str",
          "description": "Output only. The type of operation invoked."
        },
        "requested_cancellation": {
          "type": "bool",
          "description": "Output only. Identifies whether the user has requested cancellation."
        },
        "progress_percent": {
          "type": "int",
          "description": "Output only. The estimated progress of the operation in percentage [0, 100]. The value -1 means the progress is unknown."
        }
      }
    },
    {
      "type": "request_class",
      "name": "RenameFolderMetadata",
      "docstring": "Message returned in the metadata field of the Operation\nresource for RenameFolder operations.\n\nAttributes:\n    common_metadata (google.cloud.storage_control_v2.types.CommonLongRunningOperationMetadata):\n        Generic metadata for the long running\n        operation.\n    source_folder_id (str):\n        The path of the source folder.\n    destination_folder_id (str):\n        The path of the destination folder.",
      "attributes": {
        "common_metadata": {
          "type": "google.cloud.storage_control_v2.types.CommonLongRunningOperationMetadata",
          "description": "Generic metadata for the long running operation."
        },
        "source_folder_id": {
          "type": "str",
          "description": "The path of the source folder."
        },
        "destination_folder_id": {
          "type": "str",
          "description": "The path of the destination folder."
        }
      }
    },
    {
      "type": "request_class",
      "name": "StorageLayout",
      "docstring": "The storage layout configuration of a bucket.\n\nAttributes:\n    name (str):\n        Output only. The name of the StorageLayout resource. Format:\n        ``projects/{project}/buckets/{bucket}/storageLayout``\n    location (str):\n        Output only. The location of the bucket.\n    location_type (str):\n        Output only. The location type of the bucket\n        (region, dual-region, multi-region, etc).\n    custom_placement_config (google.cloud.storage_control_v2.types.StorageLayout.CustomPlacementConfig):\n        Output only. The data placement configuration\n        for custom dual region. If there is no\n        configuration, this is not a custom dual region\n        bucket.\n    hierarchical_namespace (google.cloud.storage_control_v2.types.StorageLayout.HierarchicalNamespace):\n        Output only. The bucket's hierarchical\n        namespace configuration. If there is no\n        configuration, the hierarchical namespace is\n        disabled.",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Output only. The name of the StorageLayout resource. Format: ``projects/{project}/buckets/{bucket}/storageLayout``"
        },
        "location": {
          "type": "str",
          "description": "Output only. The location of the bucket."
        },
        "location_type": {
          "type": "str",
          "description": "Output only. The location type of the bucket (region, dual-region, multi-region, etc)."
        },
        "custom_placement_config": {
          "type": "google.cloud.storage_control_v2.types.StorageLayout.CustomPlacementConfig",
          "description": "Output only. The data placement configuration for custom dual region. If there is no configuration, this is not a custom dual region bucket."
        },
        "hierarchical_namespace": {
          "type": "google.cloud.storage_control_v2.types.StorageLayout.HierarchicalNamespace",
          "description": "Output only. The bucket's hierarchical namespace configuration. If there is no configuration, the hierarchical namespace is disabled."
        }
      }
    },
    {
      "type": "request_class",
      "name": "GetStorageLayoutRequest",
      "docstring": "Request message for GetStorageLayout.\n\nAttributes:\n    name (str):\n        Required. The name of the StorageLayout resource. Format:\n        ``projects/{project}/buckets/{bucket}/storageLayout``\n    prefix (str):\n        An optional prefix used for permission check.\n        It is useful when the caller only has limited\n        permissions under a specific prefix.\n    request_id (str):\n        Optional. A unique identifier for this\n        request. UUID is the recommended format, but\n        other formats are still accepted.",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Required. The name of the StorageLayout resource. Format: ``projects/{project}/buckets/{bucket}/storageLayout``"
        },
        "prefix": {
          "type": "str",
          "description": "An optional prefix used for permission check. It is useful when the caller only has limited permissions under a specific prefix."
        },
        "request_id": {
          "type": "str",
          "description": "Optional. A unique identifier for this request. UUID is the recommended format, but other formats are still accepted."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ManagedFolder",
      "docstring": "A managed folder.\n\nAttributes:\n    name (str):\n        Identifier. The name of this managed folder. Format:\n        ``projects/{project}/buckets/{bucket}/managedFolders/{managedFolder}``\n    metageneration (int):\n        Output only. The metadata version of this\n        managed folder. It increases whenever the\n        metadata is updated. Used for preconditions and\n        for detecting changes in metadata. Managed\n        folders don't have a generation number.\n    create_time (google.protobuf.timestamp_pb2.Timestamp):\n        Output only. The creation time of the managed\n        folder.\n    update_time (google.protobuf.timestamp_pb2.Timestamp):\n        Output only. The modification time of the\n        managed folder.",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Identifier. The name of this managed folder. Format: ``projects/{project}/buckets/{bucket}/managedFolders/{managedFolder}``"
        },
        "metageneration": {
          "type": "int",
          "description": "Output only. The metadata version of this managed folder. It increases whenever the metadata is updated. Used for preconditions and for detecting changes in metadata. Managed folders don't have a generation number."
        },
        "create_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Output only. The creation time of the managed folder."
        },
        "update_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Output only. The modification time of the managed folder."
        }
      }
    },
    {
      "type": "request_class",
      "name": "GetManagedFolderRequest",
      "docstring": "Request message for GetManagedFolder.\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    name (str):\n        Required. Name of the managed folder. Format:\n        ``projects/{project}/buckets/{bucket}/managedFolders/{managedFolder}``\n    if_metageneration_match (int):\n        The operation succeeds conditional on the\n        managed folder's current metageneration matching\n        the value here specified.\n\n        This field is a member of `oneof`_ ``_if_metageneration_match``.\n    if_metageneration_not_match (int):\n        The operation succeeds conditional on the\n        managed folder's current metageneration NOT\n        matching the value here specified.\n\n        This field is a member of `oneof`_ ``_if_metageneration_not_match``.\n    request_id (str):\n        Optional. A unique identifier for this\n        request. UUID is the recommended format, but\n        other formats are still accepted.",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Required. Name of the managed folder. Format: ``projects/{project}/buckets/{bucket}/managedFolders/{managedFolder}``"
        },
        "if_metageneration_match": {
          "type": "int",
          "description": "The operation succeeds conditional on the managed folder's current metageneration matching the value here specified.  This field is a member of `oneof`_ ``_if_metageneration_match``."
        },
        "if_metageneration_not_match": {
          "type": "int",
          "description": "The operation succeeds conditional on the managed folder's current metageneration NOT matching the value here specified.  This field is a member of `oneof`_ ``_if_metageneration_not_match``."
        },
        "request_id": {
          "type": "str",
          "description": "Optional. A unique identifier for this request. UUID is the recommended format, but other formats are still accepted."
        }
      }
    },
    {
      "type": "request_class",
      "name": "CreateManagedFolderRequest",
      "docstring": "Request message for CreateManagedFolder.\n\nAttributes:\n    parent (str):\n        Required. Name of the bucket this managed\n        folder belongs to.\n    managed_folder (google.cloud.storage_control_v2.types.ManagedFolder):\n        Required. Properties of the managed folder being created.\n        The bucket and managed folder names are specified in the\n        ``parent`` and ``managed_folder_id`` fields. Populating\n        these fields in ``managed_folder`` will result in an error.\n    managed_folder_id (str):\n        Required. The name of the managed folder. It uses a single\n        ``/`` as delimiter and leading and trailing ``/`` are\n        allowed.\n    request_id (str):\n        Optional. A unique identifier for this\n        request. UUID is the recommended format, but\n        other formats are still accepted.",
      "attributes": {
        "parent": {
          "type": "str",
          "description": "Required. Name of the bucket this managed folder belongs to."
        },
        "managed_folder": {
          "type": "google.cloud.storage_control_v2.types.ManagedFolder",
          "description": "Required. Properties of the managed folder being created. The bucket and managed folder names are specified in the ``parent`` and ``managed_folder_id`` fields. Populating these fields in ``managed_folder`` will result in an error."
        },
        "managed_folder_id": {
          "type": "str",
          "description": "Required. The name of the managed folder. It uses a single ``/`` as delimiter and leading and trailing ``/`` are allowed."
        },
        "request_id": {
          "type": "str",
          "description": "Optional. A unique identifier for this request. UUID is the recommended format, but other formats are still accepted."
        }
      }
    },
    {
      "type": "request_class",
      "name": "DeleteManagedFolderRequest",
      "docstring": "DeleteManagedFolder RPC request message.\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    name (str):\n        Required. Name of the managed folder. Format:\n        ``projects/{project}/buckets/{bucket}/managedFolders/{managedFolder}``\n    if_metageneration_match (int):\n        The operation succeeds conditional on the\n        managed folder's current metageneration matching\n        the value here specified.\n\n        This field is a member of `oneof`_ ``_if_metageneration_match``.\n    if_metageneration_not_match (int):\n        The operation succeeds conditional on the\n        managed folder's current metageneration NOT\n        matching the value here specified.\n\n        This field is a member of `oneof`_ ``_if_metageneration_not_match``.\n    allow_non_empty (bool):\n        Allows deletion of a managed folder even if\n        it is not empty. A managed folder is empty if it\n        manages no child managed folders or objects.\n        Cal",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Required. Name of the managed folder. Format: ``projects/{project}/buckets/{bucket}/managedFolders/{managedFolder}``"
        },
        "if_metageneration_match": {
          "type": "int",
          "description": "The operation succeeds conditional on the managed folder's current metageneration matching the value here specified.  This field is a member of `oneof`_ ``_if_metageneration_match``."
        },
        "if_metageneration_not_match": {
          "type": "int",
          "description": "The operation succeeds conditional on the managed folder's current metageneration NOT matching the value here specified.  This field is a member of `oneof`_ ``_if_metageneration_not_match``."
        },
        "allow_non_empty": {
          "type": "bool",
          "description": "Allows deletion of a managed folder even if it is not empty. A managed folder is empty if it manages no child managed folders or objects. Caller must have permission for storage.managedFolders.setIamPolicy."
        },
        "request_id": {
          "type": "str",
          "description": "Optional. A unique identifier for this request. UUID is the recommended format, but other formats are still accepted."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ListManagedFoldersRequest",
      "docstring": "Request message for ListManagedFolders.\n\nAttributes:\n    parent (str):\n        Required. Name of the bucket this managed\n        folder belongs to.\n    page_size (int):\n        Optional. Maximum number of managed folders\n        to return in a single response. The service will\n        use this parameter or 1,000 items, whichever is\n        smaller.\n    page_token (str):\n        Optional. A previously-returned page token\n        representing part of the larger set of results\n        to view.\n    prefix (str):\n        Optional. Filter results to match managed\n        folders with name starting with this prefix.\n    request_id (str):\n        Optional. A unique identifier for this\n        request. UUID is the recommended format, but\n        other formats are still accepted.",
      "attributes": {
        "parent": {
          "type": "str",
          "description": "Required. Name of the bucket this managed folder belongs to."
        },
        "page_size": {
          "type": "int",
          "description": "Optional. Maximum number of managed folders to return in a single response. The service will use this parameter or 1,000 items, whichever is smaller."
        },
        "page_token": {
          "type": "str",
          "description": "Optional. A previously-returned page token representing part of the larger set of results to view."
        },
        "prefix": {
          "type": "str",
          "description": "Optional. Filter results to match managed folders with name starting with this prefix."
        },
        "request_id": {
          "type": "str",
          "description": "Optional. A unique identifier for this request. UUID is the recommended format, but other formats are still accepted."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ListManagedFoldersResponse",
      "docstring": "Response message for ListManagedFolders.\n\nAttributes:\n    managed_folders (MutableSequence[google.cloud.storage_control_v2.types.ManagedFolder]):\n        The list of matching managed folders\n    next_page_token (str):\n        The continuation token, used to page through\n        large result sets. Provide this value in a\n        subsequent request to return the next page of\n        results.",
      "attributes": {
        "managed_folders": {
          "type": "MutableSequence[google.cloud.storage_control_v2.types.ManagedFolder]",
          "description": "The list of matching managed folders"
        },
        "next_page_token": {
          "type": "str",
          "description": "The continuation token, used to page through large result sets. Provide this value in a subsequent request to return the next page of results."
        }
      }
    },
    {
      "type": "request_class",
      "name": "CustomPlacementConfig",
      "docstring": "Configuration for Custom Dual Regions. It should specify precisely\ntwo eligible regions within the same Multiregion. More information\non regions may be found\n[https://cloud.google.com/storage/docs/locations][here].\n\nAttributes:\n    data_locations (MutableSequence[str]):\n        List of locations to use for data placement.",
      "attributes": {
        "data_locations": {
          "type": "MutableSequence[str]",
          "description": "List of locations to use for data placement."
        }
      }
    },
    {
      "type": "request_class",
      "name": "HierarchicalNamespace",
      "docstring": "Configuration for a bucket's hierarchical namespace feature.\n\nAttributes:\n    enabled (bool):\n        Enables the hierarchical namespace feature.",
      "attributes": {
        "enabled": {
          "type": "bool",
          "description": "Enables the hierarchical namespace feature."
        }
      }
    }
  ]
}
{
  "\\Users\\AMD\\vidhra\\internal\\ast\\google-cloud-python\\packages\\google-cloud-managedkafka\\google\\cloud\\managedkafka_v1\\types\\managed_kafka.py": [
    {
      "type": "request_class",
      "name": "ListClustersRequest",
      "docstring": "Request for ListClusters.\n\nAttributes:\n    parent (str):\n        Required. The parent location whose clusters are to be\n        listed. Structured like\n        ``projects/{project}/locations/{location}``.\n    page_size (int):\n        Optional. The maximum number of clusters to\n        return. The service may return fewer than this\n        value. If unspecified, server will pick an\n        appropriate default.\n    page_token (str):\n        Optional. A page token, received from a previous\n        ``ListClusters`` call. Provide this to retrieve the\n        subsequent page.\n\n        When paginating, all other parameters provided to\n        ``ListClusters`` must match the call that provided the page\n        token.\n    filter (str):\n        Optional. Filter expression for the result.\n    order_by (str):\n        Optional. Order by fields for the result.",
      "attributes": {
        "parent": {
          "type": "str",
          "description": "Required. The parent location whose clusters are to be listed. Structured like ``projects/{project}/locations/{location}``."
        },
        "page_size": {
          "type": "int",
          "description": "Optional. The maximum number of clusters to return. The service may return fewer than this value. If unspecified, server will pick an appropriate default."
        },
        "page_token": {
          "type": "str",
          "description": "Optional. A page token, received from a previous ``ListClusters`` call. Provide this to retrieve the subsequent page.  When paginating, all other parameters provided to ``ListClusters`` must match the call that provided the page token."
        },
        "filter": {
          "type": "str",
          "description": "Optional. Filter expression for the result."
        },
        "order_by": {
          "type": "str",
          "description": "Optional. Order by fields for the result."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ListClustersResponse",
      "docstring": "Response for ListClusters.\n\nAttributes:\n    clusters (MutableSequence[google.cloud.managedkafka_v1.types.Cluster]):\n        The list of Clusters in the requested parent.\n    next_page_token (str):\n        A token that can be sent as ``page_token`` to retrieve the\n        next page of results. If this field is omitted, there are no\n        more results.\n    unreachable (MutableSequence[str]):\n        Locations that could not be reached.",
      "attributes": {
        "clusters": {
          "type": "MutableSequence[google.cloud.managedkafka_v1.types.Cluster]",
          "description": "The list of Clusters in the requested parent."
        },
        "next_page_token": {
          "type": "str",
          "description": "A token that can be sent as ``page_token`` to retrieve the next page of results. If this field is omitted, there are no more results."
        },
        "unreachable": {
          "type": "MutableSequence[str]",
          "description": "Locations that could not be reached."
        }
      }
    },
    {
      "type": "request_class",
      "name": "GetClusterRequest",
      "docstring": "Request for GetCluster.\n\nAttributes:\n    name (str):\n        Required. The name of the cluster whose\n        configuration to return.",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Required. The name of the cluster whose configuration to return."
        }
      }
    },
    {
      "type": "request_class",
      "name": "CreateClusterRequest",
      "docstring": "Request for CreateCluster.\n\nAttributes:\n    parent (str):\n        Required. The parent region in which to create the cluster.\n        Structured like ``projects/{project}/locations/{location}``.\n    cluster_id (str):\n        Required. The ID to use for the cluster, which will become\n        the final component of the cluster's name. The ID must be\n        1-63 characters long, and match the regular expression\n        ``[a-z]([-a-z0-9]*[a-z0-9])?`` to comply with RFC 1035.\n\n        This value is structured like: ``my-cluster-id``.\n    cluster (google.cloud.managedkafka_v1.types.Cluster):\n        Required. Configuration of the cluster to create. Its\n        ``name`` field is ignored.\n    request_id (str):\n        Optional. An optional request ID to identify\n        requests. Specify a unique request ID to avoid\n        duplication of requests. If a request times out\n        or fails, retrying with the same ID allows the\n        server to recognize the previous attempt. For at\n        least 60 minutes, the serve",
      "attributes": {
        "parent": {
          "type": "str",
          "description": "Required. The parent region in which to create the cluster. Structured like ``projects/{project}/locations/{location}``."
        },
        "cluster_id": {
          "type": "str",
          "description": "Required. The ID to use for the cluster, which will become the final component of the cluster's name. The ID must be 1-63 characters long, and match the regular expression ``[a-z]([-a-z0-9]*[a-z0-9])?`` to comply with RFC 1035.  This value is structured like: ``my-cluster-id``."
        },
        "cluster": {
          "type": "google.cloud.managedkafka_v1.types.Cluster",
          "description": "Required. Configuration of the cluster to create. Its ``name`` field is ignored."
        },
        "request_id": {
          "type": "str",
          "description": "Optional. An optional request ID to identify requests. Specify a unique request ID to avoid duplication of requests. If a request times out or fails, retrying with the same ID allows the server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate requests bearing the same ID.  For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID within 60 minutes of the last request, the server checks if an original operation with the same request ID was received. If so, the server ignores the second request.  The request ID must be a valid UUID. A zero UUID is not supported (00000000-0000-0000-0000-000000000000)."
        }
      }
    },
    {
      "type": "request_class",
      "name": "UpdateClusterRequest",
      "docstring": "Request for UpdateCluster.\n\nAttributes:\n    update_mask (google.protobuf.field_mask_pb2.FieldMask):\n        Required. Field mask is used to specify the fields to be\n        overwritten in the cluster resource by the update. The\n        fields specified in the update_mask are relative to the\n        resource, not the full request. A field will be overwritten\n        if it is in the mask. The mask is required and a value of \\*\n        will update all fields.\n    cluster (google.cloud.managedkafka_v1.types.Cluster):\n        Required. The cluster to update. Its ``name`` field must be\n        populated.\n    request_id (str):\n        Optional. An optional request ID to identify\n        requests. Specify a unique request ID to avoid\n        duplication of requests. If a request times out\n        or fails, retrying with the same ID allows the\n        server to recognize the previous attempt. For at\n        least 60 minutes, the server ignores duplicate\n        requests bearing the same ID.\n\n        For example, consi",
      "attributes": {
        "update_mask": {
          "type": "google.protobuf.field_mask_pb2.FieldMask",
          "description": "Required. Field mask is used to specify the fields to be overwritten in the cluster resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. The mask is required and a value of \\* will update all fields."
        },
        "cluster": {
          "type": "google.cloud.managedkafka_v1.types.Cluster",
          "description": "Required. The cluster to update. Its ``name`` field must be populated."
        },
        "request_id": {
          "type": "str",
          "description": "Optional. An optional request ID to identify requests. Specify a unique request ID to avoid duplication of requests. If a request times out or fails, retrying with the same ID allows the server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate requests bearing the same ID.  For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID within 60 minutes of the last request, the server checks if an original operation with the same request ID was received. If so, the server ignores the second request.  The request ID must be a valid UUID. A zero UUID is not supported (00000000-0000-0000-0000-000000000000)."
        }
      }
    },
    {
      "type": "request_class",
      "name": "DeleteClusterRequest",
      "docstring": "Request for DeleteCluster.\n\nAttributes:\n    name (str):\n        Required. The name of the cluster to delete.\n    request_id (str):\n        Optional. An optional request ID to identify\n        requests. Specify a unique request ID to avoid\n        duplication of requests. If a request times out\n        or fails, retrying with the same ID allows the\n        server to recognize the previous attempt. For at\n        least 60 minutes, the server ignores duplicate\n        requests bearing the same ID.\n\n        For example, consider a situation where you make\n        an initial request and the request times out. If\n        you make the request again with the same request\n        ID within 60 minutes of the last request, the\n        server checks if an original operation with the\n        same request ID was received. If so, the server\n        ignores the second request.\n\n        The request ID must be a valid UUID. A zero UUID\n        is not supported\n        (00000000-0000-0000-0000-000000000000).",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Required. The name of the cluster to delete."
        },
        "request_id": {
          "type": "str",
          "description": "Optional. An optional request ID to identify requests. Specify a unique request ID to avoid duplication of requests. If a request times out or fails, retrying with the same ID allows the server to recognize the previous attempt. For at least 60 minutes, the server ignores duplicate requests bearing the same ID.  For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID within 60 minutes of the last request, the server checks if an original operation with the same request ID was received. If so, the server ignores the second request.  The request ID must be a valid UUID. A zero UUID is not supported (00000000-0000-0000-0000-000000000000)."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ListTopicsRequest",
      "docstring": "Request for ListTopics.\n\nAttributes:\n    parent (str):\n        Required. The parent cluster whose topics are to be listed.\n        Structured like\n        ``projects/{project}/locations/{location}/clusters/{cluster}``.\n    page_size (int):\n        Optional. The maximum number of topics to\n        return. The service may return fewer than this\n        value. If unset or zero, all topics for the\n        parent is returned.\n    page_token (str):\n        Optional. A page token, received from a previous\n        ``ListTopics`` call. Provide this to retrieve the subsequent\n        page.\n\n        When paginating, all other parameters provided to\n        ``ListTopics`` must match the call that provided the page\n        token.",
      "attributes": {
        "parent": {
          "type": "str",
          "description": "Required. The parent cluster whose topics are to be listed. Structured like ``projects/{project}/locations/{location}/clusters/{cluster}``."
        },
        "page_size": {
          "type": "int",
          "description": "Optional. The maximum number of topics to return. The service may return fewer than this value. If unset or zero, all topics for the parent is returned."
        },
        "page_token": {
          "type": "str",
          "description": "Optional. A page token, received from a previous ``ListTopics`` call. Provide this to retrieve the subsequent page.  When paginating, all other parameters provided to ``ListTopics`` must match the call that provided the page token."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ListTopicsResponse",
      "docstring": "Response for ListTopics.\n\nAttributes:\n    topics (MutableSequence[google.cloud.managedkafka_v1.types.Topic]):\n        The list of topics in the requested parent.\n        The order of the topics is unspecified.\n    next_page_token (str):\n        A token that can be sent as ``page_token`` to retrieve the\n        next page of results. If this field is omitted, there are no\n        more results.",
      "attributes": {
        "topics": {
          "type": "MutableSequence[google.cloud.managedkafka_v1.types.Topic]",
          "description": "The list of topics in the requested parent. The order of the topics is unspecified."
        },
        "next_page_token": {
          "type": "str",
          "description": "A token that can be sent as ``page_token`` to retrieve the next page of results. If this field is omitted, there are no more results."
        }
      }
    },
    {
      "type": "request_class",
      "name": "GetTopicRequest",
      "docstring": "Request for GetTopic.\n\nAttributes:\n    name (str):\n        Required. The name of the topic whose\n        configuration to return. Structured like:\n\n        projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}.",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Required. The name of the topic whose configuration to return. Structured like:  projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}."
        }
      }
    },
    {
      "type": "request_class",
      "name": "CreateTopicRequest",
      "docstring": "Request for CreateTopic.\n\nAttributes:\n    parent (str):\n        Required. The parent cluster in which to create the topic.\n        Structured like\n        ``projects/{project}/locations/{location}/clusters/{cluster}``.\n    topic_id (str):\n        Required. The ID to use for the topic, which will become the\n        final component of the topic's name.\n\n        This value is structured like: ``my-topic-name``.\n    topic (google.cloud.managedkafka_v1.types.Topic):\n        Required. Configuration of the topic to create. Its ``name``\n        field is ignored.",
      "attributes": {
        "parent": {
          "type": "str",
          "description": "Required. The parent cluster in which to create the topic. Structured like ``projects/{project}/locations/{location}/clusters/{cluster}``."
        },
        "topic_id": {
          "type": "str",
          "description": "Required. The ID to use for the topic, which will become the final component of the topic's name.  This value is structured like: ``my-topic-name``."
        },
        "topic": {
          "type": "google.cloud.managedkafka_v1.types.Topic",
          "description": "Required. Configuration of the topic to create. Its ``name`` field is ignored."
        }
      }
    },
    {
      "type": "request_class",
      "name": "UpdateTopicRequest",
      "docstring": "Request for UpdateTopic.\n\nAttributes:\n    update_mask (google.protobuf.field_mask_pb2.FieldMask):\n        Required. Field mask is used to specify the fields to be\n        overwritten in the Topic resource by the update. The fields\n        specified in the update_mask are relative to the resource,\n        not the full request. A field will be overwritten if it is\n        in the mask. The mask is required and a value of \\* will\n        update all fields.\n    topic (google.cloud.managedkafka_v1.types.Topic):\n        Required. The topic to update. Its ``name`` field must be\n        populated.",
      "attributes": {
        "update_mask": {
          "type": "google.protobuf.field_mask_pb2.FieldMask",
          "description": "Required. Field mask is used to specify the fields to be overwritten in the Topic resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. The mask is required and a value of \\* will update all fields."
        },
        "topic": {
          "type": "google.cloud.managedkafka_v1.types.Topic",
          "description": "Required. The topic to update. Its ``name`` field must be populated."
        }
      }
    },
    {
      "type": "request_class",
      "name": "DeleteTopicRequest",
      "docstring": "Request for DeleteTopic.\n\nAttributes:\n    name (str):\n        Required. The name of the topic to delete.\n        ``projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}``.",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Required. The name of the topic to delete. ``projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ListConsumerGroupsRequest",
      "docstring": "Request for ListConsumerGroups.\n\nAttributes:\n    parent (str):\n        Required. The parent cluster whose consumer groups are to be\n        listed. Structured like\n        ``projects/{project}/locations/{location}/clusters/{cluster}``.\n    page_size (int):\n        Optional. The maximum number of consumer\n        groups to return. The service may return fewer\n        than this value. If unset or zero, all consumer\n        groups for the parent is returned.\n    page_token (str):\n        Optional. A page token, received from a previous\n        ``ListConsumerGroups`` call. Provide this to retrieve the\n        subsequent page.\n\n        When paginating, all other parameters provided to\n        ``ListConsumerGroups`` must match the call that provided the\n        page token.",
      "attributes": {
        "parent": {
          "type": "str",
          "description": "Required. The parent cluster whose consumer groups are to be listed. Structured like ``projects/{project}/locations/{location}/clusters/{cluster}``."
        },
        "page_size": {
          "type": "int",
          "description": "Optional. The maximum number of consumer groups to return. The service may return fewer than this value. If unset or zero, all consumer groups for the parent is returned."
        },
        "page_token": {
          "type": "str",
          "description": "Optional. A page token, received from a previous ``ListConsumerGroups`` call. Provide this to retrieve the subsequent page.  When paginating, all other parameters provided to ``ListConsumerGroups`` must match the call that provided the page token."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ListConsumerGroupsResponse",
      "docstring": "Response for ListConsumerGroups.\n\nAttributes:\n    consumer_groups (MutableSequence[google.cloud.managedkafka_v1.types.ConsumerGroup]):\n        The list of consumer group in the requested\n        parent. The order of the consumer groups is\n        unspecified.\n    next_page_token (str):\n        A token that can be sent as ``page_token`` to retrieve the\n        next page of results. If this field is omitted, there are no\n        more results.",
      "attributes": {
        "consumer_groups": {
          "type": "MutableSequence[google.cloud.managedkafka_v1.types.ConsumerGroup]",
          "description": "The list of consumer group in the requested parent. The order of the consumer groups is unspecified."
        },
        "next_page_token": {
          "type": "str",
          "description": "A token that can be sent as ``page_token`` to retrieve the next page of results. If this field is omitted, there are no more results."
        }
      }
    },
    {
      "type": "request_class",
      "name": "GetConsumerGroupRequest",
      "docstring": "Request for GetConsumerGroup.\n\nAttributes:\n    name (str):\n        Required. The name of the consumer group whose configuration\n        to return.\n        ``projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}``.",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Required. The name of the consumer group whose configuration to return. ``projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "UpdateConsumerGroupRequest",
      "docstring": "Request for UpdateConsumerGroup.\n\nAttributes:\n    update_mask (google.protobuf.field_mask_pb2.FieldMask):\n        Required. Field mask is used to specify the fields to be\n        overwritten in the ConsumerGroup resource by the update. The\n        fields specified in the update_mask are relative to the\n        resource, not the full request. A field will be overwritten\n        if it is in the mask. The mask is required and a value of \\*\n        will update all fields.\n    consumer_group (google.cloud.managedkafka_v1.types.ConsumerGroup):\n        Required. The consumer group to update. Its ``name`` field\n        must be populated.",
      "attributes": {
        "update_mask": {
          "type": "google.protobuf.field_mask_pb2.FieldMask",
          "description": "Required. Field mask is used to specify the fields to be overwritten in the ConsumerGroup resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. The mask is required and a value of \\* will update all fields."
        },
        "consumer_group": {
          "type": "google.cloud.managedkafka_v1.types.ConsumerGroup",
          "description": "Required. The consumer group to update. Its ``name`` field must be populated."
        }
      }
    },
    {
      "type": "request_class",
      "name": "DeleteConsumerGroupRequest",
      "docstring": "Request for DeleteConsumerGroup.\n\nAttributes:\n    name (str):\n        Required. The name of the consumer group to delete.\n        ``projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}``.",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Required. The name of the consumer group to delete. ``projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumerGroup}``."
        }
      }
    }
  ],
  "\\Users\\AMD\\vidhra\\internal\\ast\\google-cloud-python\\packages\\google-cloud-managedkafka\\google\\cloud\\managedkafka_v1\\types\\resources.py": [
    {
      "type": "request_class",
      "name": "Cluster",
      "docstring": "An Apache Kafka cluster deployed in a location.\n\n.. _oneof: https://proto-plus-python.readthedocs.io/en/stable/fields.html#oneofs-mutually-exclusive-fields\n\nAttributes:\n    gcp_config (google.cloud.managedkafka_v1.types.GcpConfig):\n        Required. Configuration properties for a\n        Kafka cluster deployed to Google Cloud Platform.\n\n        This field is a member of `oneof`_ ``platform_config``.\n    name (str):\n        Identifier. The name of the cluster. Structured like:\n        projects/{project_number}/locations/{location}/clusters/{cluster_id}\n    create_time (google.protobuf.timestamp_pb2.Timestamp):\n        Output only. The time when the cluster was\n        created.\n    update_time (google.protobuf.timestamp_pb2.Timestamp):\n        Output only. The time when the cluster was\n        last updated.\n    labels (MutableMapping[str, str]):\n        Optional. Labels as key value pairs.\n    capacity_config (google.cloud.managedkafka_v1.types.CapacityConfig):\n        Required. Capacity configuration for the\n ",
      "attributes": {
        "gcp_config": {
          "type": "google.cloud.managedkafka_v1.types.GcpConfig",
          "description": "Required. Configuration properties for a Kafka cluster deployed to Google Cloud Platform.  This field is a member of `oneof`_ ``platform_config``."
        },
        "name": {
          "type": "str",
          "description": "Identifier. The name of the cluster. Structured like: projects/{project_number}/locations/{location}/clusters/{cluster_id}"
        },
        "create_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Output only. The time when the cluster was created."
        },
        "update_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Output only. The time when the cluster was last updated."
        },
        "labels": {
          "type": "MutableMapping[str, str]",
          "description": "Optional. Labels as key value pairs."
        },
        "capacity_config": {
          "type": "google.cloud.managedkafka_v1.types.CapacityConfig",
          "description": "Required. Capacity configuration for the Kafka cluster."
        },
        "rebalance_config": {
          "type": "google.cloud.managedkafka_v1.types.RebalanceConfig",
          "description": "Optional. Rebalance configuration for the Kafka cluster."
        },
        "state": {
          "type": "google.cloud.managedkafka_v1.types.Cluster.State",
          "description": "Output only. The current state of the cluster."
        }
      }
    },
    {
      "type": "request_class",
      "name": "CapacityConfig",
      "docstring": "A capacity configuration of a Kafka cluster.\n\nAttributes:\n    vcpu_count (int):\n        Required. The number of vCPUs to provision\n        for the cluster. Minimum: 3.\n    memory_bytes (int):\n        Required. The memory to provision for the\n        cluster in bytes. The CPU:memory ratio\n        (vCPU:GiB) must be between 1:1 and 1:8. Minimum:\n        3221225472 (3 GiB).",
      "attributes": {
        "vcpu_count": {
          "type": "int",
          "description": "Required. The number of vCPUs to provision for the cluster. Minimum: 3."
        },
        "memory_bytes": {
          "type": "int",
          "description": "Required. The memory to provision for the cluster in bytes. The CPU:memory ratio (vCPU:GiB) must be between 1:1 and 1:8. Minimum: 3221225472 (3 GiB)."
        }
      }
    },
    {
      "type": "request_class",
      "name": "RebalanceConfig",
      "docstring": "Defines rebalancing behavior of a Kafka cluster.\n\nAttributes:\n    mode (google.cloud.managedkafka_v1.types.RebalanceConfig.Mode):\n        Optional. The rebalance behavior for the cluster. When not\n        specified, defaults to ``NO_REBALANCE``.",
      "attributes": {
        "mode": {
          "type": "google.cloud.managedkafka_v1.types.RebalanceConfig.Mode",
          "description": "Optional. The rebalance behavior for the cluster. When not specified, defaults to ``NO_REBALANCE``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "NetworkConfig",
      "docstring": "The configuration of a Virtual Private Cloud (VPC) network\nthat can access the Kafka cluster.\n\nAttributes:\n    subnet (str):\n        Required. Name of the VPC subnet in which to create Private\n        Service Connect (PSC) endpoints for the Kafka brokers and\n        bootstrap address. Structured like:\n        projects/{project}/regions/{region}/subnetworks/{subnet_id}\n\n        The subnet must be located in the same region as the Kafka\n        cluster. The project may differ. Multiple subnets from the\n        same parent network must not be specified.\n\n        The CIDR range of the subnet must be within the IPv4 address\n        ranges for private networks, as specified in RFC 1918.",
      "attributes": {
        "subnet": {
          "type": "str",
          "description": "Required. Name of the VPC subnet in which to create Private Service Connect (PSC) endpoints for the Kafka brokers and bootstrap address. Structured like: projects/{project}/regions/{region}/subnetworks/{subnet_id}  The subnet must be located in the same region as the Kafka cluster. The project may differ. Multiple subnets from the same parent network must not be specified.  The CIDR range of the subnet must be within the IPv4 address ranges for private networks, as specified in RFC 1918."
        }
      }
    },
    {
      "type": "request_class",
      "name": "AccessConfig",
      "docstring": "The configuration of access to the Kafka cluster.\n\nAttributes:\n    network_configs (MutableSequence[google.cloud.managedkafka_v1.types.NetworkConfig]):\n        Required. Virtual Private Cloud (VPC)\n        networks that must be granted direct access to\n        the Kafka cluster. Minimum of 1 network is\n        required. Maximum 10 networks can be specified.",
      "attributes": {
        "network_configs": {
          "type": "MutableSequence[google.cloud.managedkafka_v1.types.NetworkConfig]",
          "description": "Required. Virtual Private Cloud (VPC) networks that must be granted direct access to the Kafka cluster. Minimum of 1 network is required. Maximum 10 networks can be specified."
        }
      }
    },
    {
      "type": "request_class",
      "name": "GcpConfig",
      "docstring": "Configuration properties for a Kafka cluster deployed to\nGoogle Cloud Platform.\n\nAttributes:\n    access_config (google.cloud.managedkafka_v1.types.AccessConfig):\n        Required. Access configuration for the Kafka\n        cluster.\n    kms_key (str):\n        Optional. Immutable. The Cloud KMS Key name to use for\n        encryption. The key must be located in the same region as\n        the cluster and cannot be changed. Structured like:\n        projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}.",
      "attributes": {
        "access_config": {
          "type": "google.cloud.managedkafka_v1.types.AccessConfig",
          "description": "Required. Access configuration for the Kafka cluster."
        },
        "kms_key": {
          "type": "str",
          "description": "Optional. Immutable. The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Structured like: projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}."
        }
      }
    },
    {
      "type": "request_class",
      "name": "Topic",
      "docstring": "A Kafka topic in a given cluster.\n\nAttributes:\n    name (str):\n        Identifier. The name of the topic. The ``topic`` segment is\n        used when connecting directly to the cluster. Structured\n        like:\n        projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}\n    partition_count (int):\n        Required. The number of partitions this topic\n        has. The partition count can only be increased,\n        not decreased. Please note that if partitions\n        are increased for a topic that has a key, the\n        partitioning logic or the ordering of the\n        messages will be affected.\n    replication_factor (int):\n        Required. Immutable. The number of replicas\n        of each partition. A replication factor of 3 is\n        recommended for high availability.\n    configs (MutableMapping[str, str]):\n        Optional. Configurations for the topic that are overridden\n        from the cluster defaults. The key of the map is a Kafka\n        topic property name, for example: ``clean",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Identifier. The name of the topic. The ``topic`` segment is used when connecting directly to the cluster. Structured like: projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}"
        },
        "partition_count": {
          "type": "int",
          "description": "Required. The number of partitions this topic has. The partition count can only be increased, not decreased. Please note that if partitions are increased for a topic that has a key, the partitioning logic or the ordering of the messages will be affected."
        },
        "replication_factor": {
          "type": "int",
          "description": "Required. Immutable. The number of replicas of each partition. A replication factor of 3 is recommended for high availability."
        },
        "configs": {
          "type": "MutableMapping[str, str]",
          "description": "Optional. Configurations for the topic that are overridden from the cluster defaults. The key of the map is a Kafka topic property name, for example: ``cleanup.policy``, ``compression.type``."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ConsumerTopicMetadata",
      "docstring": "Metadata for a consumer group corresponding to a specific\ntopic.\n\nAttributes:\n    partitions (MutableMapping[int, google.cloud.managedkafka_v1.types.ConsumerPartitionMetadata]):\n        Optional. Metadata for this consumer group\n        and topic for all partition indexes it has\n        metadata for.",
      "attributes": {
        "partitions": {
          "type": "MutableMapping[int, google.cloud.managedkafka_v1.types.ConsumerPartitionMetadata]",
          "description": "Optional. Metadata for this consumer group and topic for all partition indexes it has metadata for."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ConsumerPartitionMetadata",
      "docstring": "Metadata for a consumer group corresponding to a specific\npartition.\n\nAttributes:\n    offset (int):\n        Required. The current offset for this\n        partition, or 0 if no offset has been committed.\n    metadata (str):\n        Optional. The associated metadata for this\n        partition, or empty if it does not exist.",
      "attributes": {
        "offset": {
          "type": "int",
          "description": "Required. The current offset for this partition, or 0 if no offset has been committed."
        },
        "metadata": {
          "type": "str",
          "description": "Optional. The associated metadata for this partition, or empty if it does not exist."
        }
      }
    },
    {
      "type": "request_class",
      "name": "ConsumerGroup",
      "docstring": "A Kafka consumer group in a given cluster.\n\nAttributes:\n    name (str):\n        Identifier. The name of the consumer group. The\n        ``consumer_group`` segment is used when connecting directly\n        to the cluster. Structured like:\n        projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}\n    topics (MutableMapping[str, google.cloud.managedkafka_v1.types.ConsumerTopicMetadata]):\n        Optional. Metadata for this consumer group\n        for all topics it has metadata for. The key of\n        the map is a topic name, structured like:\n\n        projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}",
      "attributes": {
        "name": {
          "type": "str",
          "description": "Identifier. The name of the consumer group. The ``consumer_group`` segment is used when connecting directly to the cluster. Structured like: projects/{project}/locations/{location}/clusters/{cluster}/consumerGroups/{consumer_group}"
        },
        "topics": {
          "type": "MutableMapping[str, google.cloud.managedkafka_v1.types.ConsumerTopicMetadata]",
          "description": "Optional. Metadata for this consumer group for all topics it has metadata for. The key of the map is a topic name, structured like:  projects/{project}/locations/{location}/clusters/{cluster}/topics/{topic}"
        }
      }
    },
    {
      "type": "request_class",
      "name": "OperationMetadata",
      "docstring": "Represents the metadata of the long-running operation.\n\nAttributes:\n    create_time (google.protobuf.timestamp_pb2.Timestamp):\n        Output only. The time the operation was\n        created.\n    end_time (google.protobuf.timestamp_pb2.Timestamp):\n        Output only. The time the operation finished\n        running.\n    target (str):\n        Output only. Server-defined resource path for\n        the target of the operation.\n    verb (str):\n        Output only. Name of the verb executed by the\n        operation.\n    status_message (str):\n        Output only. Human-readable status of the\n        operation, if any.\n    requested_cancellation (bool):\n        Output only. Identifies whether the user has requested\n        cancellation of the operation. Operations that have been\n        cancelled successfully have [Operation.error][] value with a\n        [google.rpc.Status.code][google.rpc.Status.code] of 1,\n        corresponding to ``Code.CANCELLED``.\n    api_version (str):\n        Output only. API version used to s",
      "attributes": {
        "create_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Output only. The time the operation was created."
        },
        "end_time": {
          "type": "google.protobuf.timestamp_pb2.Timestamp",
          "description": "Output only. The time the operation finished running."
        },
        "target": {
          "type": "str",
          "description": "Output only. Server-defined resource path for the target of the operation."
        },
        "verb": {
          "type": "str",
          "description": "Output only. Name of the verb executed by the operation."
        },
        "status_message": {
          "type": "str",
          "description": "Output only. Human-readable status of the operation, if any."
        },
        "requested_cancellation": {
          "type": "bool",
          "description": "Output only. Identifies whether the user has requested cancellation of the operation. Operations that have been cancelled successfully have [Operation.error][] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to ``Code.CANCELLED``."
        },
        "api_version": {
          "type": "str",
          "description": "Output only. API version used to start the operation."
        }
      }
    }
  ]
}